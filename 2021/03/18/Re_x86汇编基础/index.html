<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Re_x86汇编基础 | AloofのBlog</title><meta name="keywords" content="Reverse,汇编,x86"><meta name="author" content="Aloof"><meta name="copyright" content="Aloof"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="X86 汇编基础   寄存器 Registers 现代 ( 386及以上的机器 )x86 处理器有 8 个 32 位通用寄存器.  这些寄存器的名字都是有点历史的, 例如 EAX 过去被称为 累加器, 因为它被用来作很多算术运算, 还有 ECX 被称为 计数器 , 因为它被用来保存循环的索引 ( 就是循环次数 ). 尽管大多是寄存器在现代指令集中已经失去了它们的特殊用途, 但是按照惯例, 其中有两">
<meta property="og:type" content="article">
<meta property="og:title" content="Re_x86汇编基础">
<meta property="og:url" content="https://aloof77.github.io/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="AloofのBlog">
<meta property="og:description" content="X86 汇编基础   寄存器 Registers 现代 ( 386及以上的机器 )x86 处理器有 8 个 32 位通用寄存器.  这些寄存器的名字都是有点历史的, 例如 EAX 过去被称为 累加器, 因为它被用来作很多算术运算, 还有 ECX 被称为 计数器 , 因为它被用来保存循环的索引 ( 就是循环次数 ). 尽管大多是寄存器在现代指令集中已经失去了它们的特殊用途, 但是按照惯例, 其中有两">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aloof77.github.io/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/font.jpg">
<meta property="article:published_time" content="2021-03-18T15:47:45.000Z">
<meta property="article:modified_time" content="2021-03-25T23:50:34.988Z">
<meta property="article:author" content="Aloof">
<meta property="article:tag" content="Reverse">
<meta property="article:tag" content="汇编">
<meta property="article:tag" content="x86">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aloof77.github.io/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/font.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://aloof77.github.io/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a9cb0392955c54f59a126cf13f43e1b0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-26 07:50:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/back.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AloofのBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Re_x86汇编基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-18T15:47:45.000Z" title="发表于 2021-03-18 23:47:45">2021-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-25T23:50:34.988Z" title="更新于 2021-03-26 07:50:34">2021-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Reverse/">Reverse</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Reverse/%E6%B1%87%E7%BC%96/">汇编</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Reverse/%E6%B1%87%E7%BC%96/x86/">x86</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>X86 汇编基础</strong></p>
<hr>
<hr>
<h1 id="寄存器-Registers"><a href="#寄存器-Registers" class="headerlink" title="寄存器 Registers"></a>寄存器 Registers</h1><hr>
<p>现代 ( 386及以上的机器 )x86 处理器有 8 个 32 位通用寄存器.</p>
<p><img src="/images/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80_x86-registers.png" alt="x86-registers"></p>
<p>这些寄存器的名字都是有点历史的, 例如 <code>EAX</code> 过去被称为 <em>累加器</em>, 因为它被用来作很多算术运算, 还有 <code>ECX</code> 被称为 <em>计数器</em> , 因为它被用来保存循环的索引 ( 就是循环次数 ). 尽管大多是寄存器在现代指令集中已经失去了它们的特殊用途, 但是按照惯例, 其中有两个寄存器还是有它们的特殊用途 —<code>ESP</code> 和 <code>EBP</code> .</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freeking101/article/details/99093930">寄存器</a>就好比是 CPU 身上的口袋，方便 CPU 随时从里面拿出需要的东西来使用.</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EBA: 扩展基址寄存器</span><br><span class="line">ECX: 扩展计数寄存器</span><br><span class="line">EDX: 扩展数据寄存器</span><br><span class="line">ESI: 扩展来源寄存器</span><br><span class="line">EDI: 扩展目标寄存器</span><br><span class="line"></span><br><span class="line">EBP：扩展基址指针寄存器</span><br><span class="line">ESP：扩展堆栈指针寄存器.栈顶指针，指向当前堆栈的栈底</span><br><span class="line">EIP：扩展指令指针寄存器</span><br></pre></td></tr></table></figure>

<p><img src="/images/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80_stack.jpg" alt="stack"></p>
<p>对于 <code>EAS</code>, <code>EBX</code>, <code>ECX</code> 还有 <code>EDX</code> 寄存器, 它们可以被分段开来使用. 例如, 可以将 <code>EAX</code> 的最低的 2 位字节视为 16 位寄存器  <code>AX</code> . 还可以将 <code>AX</code> 的最低位的 1 个字节看成 8 位寄存器来用  <code>AL</code>, 当然 <code>AX</code> 的高位的 1 个字节也可以看成是一个 8 位寄存器  <code>AH</code> . 这些名称有它们相对应的物理寄存器. 当两个字节大小的数据被放到 <code>DX</code> 的时候, 原本 <code>DH</code>, <code>DL</code> 和 <code>EDX</code> 的数据会受到影响 ( 被覆盖之类的 ). 这些 “ 子寄存器 “ 主要来自于比较久远的 16 位版本指令集. 然而, 在处理小于 32 位的数据的时候, 比如 1 个字节的 ASCII 字符, 它们有时会很方便stack.</p>
<h1 id="内存和寻址模式-Memory-and-Addressing-Modes"><a href="#内存和寻址模式-Memory-and-Addressing-Modes" class="headerlink" title="内存和寻址模式 Memory and Addressing Modes"></a>内存和寻址模式 Memory and Addressing Modes</h1><hr>
<h2 id="声明静态数据区域"><a href="#声明静态数据区域" class="headerlink" title="声明静态数据区域"></a>声明静态数据区域</h2><p>可以用特殊的x86汇编指令在内存中声明静态数据区域(类似于全局变量). <code>.data</code>指令用来声明数据，**<code>根据这条指令，.byte，.short 和.long可以分别用来声明1个字节，2个字节和4个字节的数据.</code><strong>我们可以给它们打个标签, 用来引用创建的数据的地址. <em><em>标签在汇编语言中是非常有用的, 它们给内存地址命名, 然后</em>编译器* 和*链接器</em> 将其 “ 翻译 “ 成计算机理解的机器代码.</strong> 这个跟用名称来声明变量很类似, 但是它遵守一些较低级别的规则. 例如, 按顺序声明的位置将彼此相邻地存储在内存中. 这话也许有点绕, 就是按照顺序打的标签, 这些标签对应的数据也会按照顺序被放到内存中.例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var :</span><br><span class="line">       .byte 64 ;	&#x2F;&#x2F;声明一个字节型变量 var, 其所对应的数据是64</span><br><span class="line">       .byte 10 ;	&#x2F;&#x2F;声明一个数据 10, 这个数据没有所谓的 &quot; 标签 &quot;, 它的内存地址就是 var+1.</span><br><span class="line"></span><br><span class="line">x :</span><br><span class="line">       .short 42 ;	&#x2F;&#x2F;声明一个大小为 2 个字节的数据, 这个数据有个标签 &quot; x &quot;</span><br><span class="line"></span><br><span class="line">y :</span><br><span class="line">       .long 30000 ;	&#x2F;&#x2F;声明一个大小为 4 个字节的数据, 这个数据标签是 &quot; y &quot;,  y 的值被初始化为 30000</span><br></pre></td></tr></table></figure>

<p>与高级语言不同, 高级语言的数组可以具有多个维度并且可以通过索引来访问, x86 汇编语言的数组只是在内存中连续的” 单元格 “. <strong>只需要把数值列出来就可以声明一个数组</strong>, 比如下面的第一个例子. 对于一些字节型数组的特殊情况, 我们可以使用字符串. 如果要在大多数的内存填充 0, 你可以使用<code>.zero</code>指令.例子 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s :</span><br><span class="line">       .long 1, 2, 3 ;	&#x2F;&#x2F;声明 3 个大小为 4 字节的数据 1, 2, 3. 内存中 s+8 这个标签所对应的数据就是 3.</span><br><span class="line"></span><br><span class="line">barr:</span><br><span class="line">       .zero 10 ;	&#x2F;&#x2F;从 barr 这个标签的位置开始, 声明 10 个字节的数据, 这些数据被初始化为 0.</span><br><span class="line"></span><br><span class="line">str :</span><br><span class="line">       .string &quot;hello&quot; ;	&#x2F;&#x2F;从 str 这个标签的位置开始, 声明 6 个字节的数据, 即 hello 对应的 ASCII 值, 这最后还跟有一个 nul(0) 字节.</span><br></pre></td></tr></table></figure>

<h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><p>现代x86兼容处理器能够寻址高达 2^32 字节的内存 : 内存地址为 32 位宽. 在上面的示例中，我们使用标签来引用内存区域，这些标签实际上被 32 位数据的汇编程序替换，这些数据指定了内存中的地址. 除了支持通过标签（即常数值）引用存储区域之外，x86提供了一种灵活的计算和引用内存地址的方案 ：最多可将两个32位寄存器和一个32位有符号常量相加，以计算存储器地址. 其中一个寄存器可以选择预先乘以 2, 4 或 8.</p>
<p>寻址模式可以和许多 x86 指令一起使用. 这里用<code>mov</code>指令在寄存器和内存中移动数据当作例子. *这个指令有两个参数, 第一个是数据的来源, 第二个是数据的去向.*一些<code>mov</code>的例子 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov (%ebx), %eax ;		&#x2F;&#x2F;从 EBX 中的内存地址加载 4 个字节的数据到 EAX, 就是把 EBX 中的内容当作标签, 这个标签在内存中对应的数据放到 EAX 中;后面如果没有说明的话, (%ebx)就表示寄存器ebx中存储的内容</span><br><span class="line"></span><br><span class="line">mov %ebx, var(,1) ; 	&#x2F;&#x2F;将 EBX 中的 4 个字节大小的数据移动的内存中标签为 var 的地方去.( var 是一个 32 位常数).</span><br><span class="line"></span><br><span class="line">mov (%esi, %ebx, 4), %edx ;		&#x2F;&#x2F;将内存中标签为 ESI+4*EBX 所对应的 4 个字节大小的数据移动到 EDX中.</span><br></pre></td></tr></table></figure>

<p>一些<strong>错误</strong>的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov (%ebx, %ecx, -1), %eax ;	&#x2F;&#x2F;这个只能把寄存器中的值加上一遍.</span><br><span class="line">mov %ebx,(%eax, %esi, %edi, 1) ;	&#x2F;&#x2F;在地址计算中, 最多只能出现 2 个寄存器, 这里却有 3 个寄存器.</span><br></pre></td></tr></table></figure>

<h2 id="操作后缀"><a href="#操作后缀" class="headerlink" title="操作后缀"></a>操作后缀</h2><p>通常, 给定内存地址的数据类型可以从引用它的汇编指令推断出来. 例如, 在上面的指令中, 你可以从寄存器操作数的大小来推出其所占的内存大小. 当我们加载一个 32 位的寄存器的时候, 编译器就可以推断出我们用到的内存大小是 4 个字节宽. 当我们将 1 个字节宽的寄存器的值保存到内存中时, 编译器可以推断出我们想要在内存中弄个 1 字节大小的 “ 坑 “ 来保存我们的数据.</p>
<p>然而在某些情况下, 我们用到的内存中 “ 坑 “ 的大小是不明确的. 比如说这条指令 <code>mov $2,(%ebx)</code>. 这条指令是否应该将 “ 2 “ 这个值移动到 EBX 中的值所代表的地址 “ 坑 “ 的单个字节中 ? 也许它表示的是将 32 位整数表示的 2 移动到从地址 EBX 开始的 4 字节. 既然这两个解释都有道理, 但计算机汇编程序必须明确哪个解释才是正确的, 计算机很单纯的, 要么是错的要么是对的. 前缀 b, w, 和 l 就是来解决这个问题的, 它们分别表示 1, 2 和 4 个字节的大小.例子 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movb $2, (%ebx) ;	&#x2F;&#x2F;将 2 移入到 ebx 中的值所表示的地址单元中.</span><br><span class="line">movw $2, (%ebx) ;	&#x2F;&#x2F;将 16 位整数 2 移动到 从 ebx 中的值所表示的地址单元 开始的 2 个字节中.</span><br><span class="line">movl $2,(%ebx) ;	&#x2F;&#x2F;将 32 位整数 2 移动到 从 ebx中的值表示的地址单元 开始的 4 个字节中.</span><br></pre></td></tr></table></figure>

<h1 id="指令-Instructions"><a href="#指令-Instructions" class="headerlink" title="指令 Instructions"></a>指令 Instructions</h1><hr>
<p>机器指令通常分为 3 类 : 数据移动指令, 逻辑运算指令和流程控制指令. 完整的指令列表, 请参阅 <a target="_blank" rel="noopener" href="https://max.book118.com/html/2016/0414/40417180.shtm">intel 的指令集参考手册</a>.</p>
<p>下面将使用以下符号 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;reg32 任意的 32 位寄存器 (%eax, %ebx, %ecx, %edx, %esi, %edi, %esp 或者 %eb)</span><br><span class="line">&lt;reg16 任意的 16 位寄存器 (%ax, %bx, %cx 或者 %dx)</span><br><span class="line">&lt;reg8 任意的 8 位寄存器 (%ah, %al, %bh, %bl, %ch, %cl, %dh, %dl)</span><br><span class="line">&lt;reg 任意的寄存器</span><br><span class="line">&lt;mem 一个内存地址, 例如 (%eax), 4+var, (%eax, %ebx, 1)</span><br><span class="line">&lt;con32 32 位常数</span><br><span class="line">&lt;con16 16 位常数</span><br><span class="line">&lt;con8 8 位常数</span><br><span class="line">&lt;con 任意 32位, 16 位或者 8 位常数</span><br></pre></td></tr></table></figure>

<p>在汇编语言中, 用作<em>立即操作数</em> 的所有标签和数字常量 ( 即不在诸如<code>3 (%eax, %ebx, 8)</code>这样的地址计算中 ) 总是以美元符号 $ 为前缀. 需要的时候, 前缀 0x 表示十六进制数, 例如<code>$ 0xABC</code>. 如果没有前缀, 则默认该数字为十进制数.</p>
<h2 id="数据移动指令"><a href="#数据移动指令" class="headerlink" title="数据移动指令"></a>数据移动指令</h2><h3 id="mov-移动"><a href="#mov-移动" class="headerlink" title="mov 移动"></a><code>mov</code> 移动</h3><p><code>mov</code> 指令将数据从它的第一个参数 ( 即寄存器中的内容, 内存单元中的内容, 或者一个常数值 ) 复制到它的第二个参数 ( 即寄存器或者内存单元 ). 当寄存器到寄存器之间的数据移动是可行的时候, 直接地从内存单元中将数据移动到另一内存单元中是不行的. 在这种需要在内存单元中传递数据的情况下, 它数据来源的那个内存单元必须首先把那个内存单元中的数据加载到一个寄存器中, 然后才可以通过这个寄存器来把数据移动到目标内存单元中.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov &lt;reg, &lt;reg</span><br><span class="line">mov &lt;reg, &lt;mem</span><br><span class="line">mov &lt;mem, &lt;reg</span><br><span class="line">mov &lt;con, &lt;reg</span><br><span class="line">mov &lt;con, &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov %ebx, %eax ;	&#x2F;&#x2F;将 EBX 中的值复制到 EAX 中</span><br><span class="line">mov $5, var(,1) ;	&#x2F;&#x2F;将数字 5 存到字节型内存单元 &quot; var &quot;</span><br></pre></td></tr></table></figure>

<h3 id="push-入栈"><a href="#push-入栈" class="headerlink" title="push 入栈"></a><code>push</code> 入栈</h3><p><code>push</code>指令将它的参数移动到硬件支持的<strong>栈</strong>内存顶端. 特别地, <strong><code>push</code> 首先将 ESP 中的值减少 4,</strong> 然后将它的参数移动到一个 32 位的地址单元 ( %esp ). ESP ( 栈指针 ) 会随着不断入栈从而持续递减, 即<em><strong>栈内存是从高地址单元到低地址单元增长.</strong></em></p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push &lt;reg32</span><br><span class="line">push &lt;mem</span><br><span class="line">push &lt;con32</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %eax ;		&#x2F;&#x2F;将 EAX 送入栈</span><br><span class="line">push var(,1) ;		&#x2F;&#x2F;将 var 对应的 4 字节大小的数据送入栈中</span><br></pre></td></tr></table></figure>

<h3 id="pop-出栈"><a href="#pop-出栈" class="headerlink" title="pop 出栈"></a><code>pop</code> 出栈</h3><p><code>pop</code>指令从硬件支持的栈内存顶端移除 4 字节的数据, 并把这个数据放到该指令指定的参数中 ( 即寄存器或者内存单元 ). 其首先将内存中 ( %esp ) 的 4 字节数据放到指定的寄存器或者内存单元中, <strong>然后让 ESP + 4.</strong></p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop &lt;reg32</span><br><span class="line">pop &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop %edi ;		&#x2F;&#x2F;将栈顶的元素移除, 并放入到寄存器 EDI 中.</span><br><span class="line">pop (%ebx) ;	&#x2F;&#x2F;将栈顶的元素移除, 并放入从 EBX 开始的 4 个字节大小的内存单元中.</span><br></pre></td></tr></table></figure>

<p><strong>重点内容 : 栈 栈是一种特殊的存储空间, 特殊在它的访问形式上, 它的访问形式就是最后进入这个空间的数据, 最先出去, 也就是 “先进后出, 后进先出”.</strong></p>
<h3 id="lea加载有效地址"><a href="#lea加载有效地址" class="headerlink" title="lea加载有效地址"></a><code>lea</code>加载有效地址</h3><p><code>lea</code>指令将其第一个参数指定的<strong>内存单元</strong> 放入到 第二个参数指定的寄存器中. 注意, 该指令不加载内存单元中的内容, 只是计算有效地址并将其放入寄存器. 这对于获得指向存储器区域的指针或者执行简单的算术运算非常有用.</p>
<p>也许这里你会看得一头雾水, 不过你不必担心, 这里有更为通俗易懂的解释. <a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/427095565.html"><strong>汇编语言中 lea 指令和 mov 指令的区别 ?</strong></a> <strong><code>MOV</code> 指令的功能是传送数据</strong>，例如 <code>MOV AX,[1000H]</code>，作用是将 1000H 作为偏移地址，寻址找到内存单元，将该内存单元中的数据送至 AX； <strong><code>LEA</code> 指令的功能是取偏移地址</strong>，例如 <code>LEA AX,[1000H]</code>，作用是将源操作数 [1000H] 的偏移地址 1000H 送至 AX.理解时，可直接将[ ]去掉，等同于 <code>MOV AX,1000H</code>. 再如：<code>LEA BX,[AX]</code>，等同于 <code>MOV BX,AX</code>；<code>LEA BX,TABLE</code> 等同于 <code>MOV BX,OFFSET TABLE</code>. 但有时不能直接使用 <code>MOV</code> 代替： 比如：<code>LEA AX,[SI+6]</code> 不能直接替换成：<code>MOV AX,SI+6</code>；但可替换为： <code>MOV AX,SI</code> <code>ADD AX,6</code> 两步完成.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea &lt;mem, &lt;reg32</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea (%ebx,%esi,8), %edi ;	&#x2F;&#x2F;EBX+8*ESI 的值被移入到了 EDI</span><br><span class="line">lea val(,1), %eax ;		&#x2F;&#x2F;val 的值被移入到了 EAX</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><h3 id="add-整数相加"><a href="#add-整数相加" class="headerlink" title="add 整数相加"></a><code>add</code> 整数相加</h3><p><code>add</code> 指令将两个参数相加, 然后将结果存放到第二个参数中. 注意, <strong>参数可以是寄存器,但参数中最多只有一个内存单元.</strong> 这话有点绕, 我们直接看语法 :</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add &lt;reg, &lt;reg</span><br><span class="line">add &lt;mem, &lt;reg</span><br><span class="line">add &lt;reg, &lt;mem</span><br><span class="line">add &lt;con, &lt;reg</span><br><span class="line">add &lt;con, &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add $10, %eax ;		&#x2F;&#x2F;EAX 中的值被设置为了 EAX+10.</span><br><span class="line">addb $10, (%eax) ;		&#x2F;&#x2F;往 EAX 中的值 所代表的内存单元地址 加上 1 个字节的数字 10.</span><br></pre></td></tr></table></figure>

<h3 id="sub-整数相减"><a href="#sub-整数相减" class="headerlink" title="sub 整数相减"></a><code>sub</code> 整数相减</h3><p><code>sub</code>指令<strong>将第二个参数的值与第一个相减, 就是后面那个减去前面那个, 然后把结果存储到第二个参数</strong>. 和<code>add</code>一样, 两个参数都可以是寄存器, 但两个参数中最多只能有一个是内存单元.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub &lt;reg, &lt;reg</span><br><span class="line">sub &lt;mem, &lt;reg</span><br><span class="line">sub &lt;con, &lt;reg</span><br><span class="line">sub &lt;con, &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub %ah, %al ;		&#x2F;&#x2F;AL 被设置成 AL-AH</span><br><span class="line">sub $216, %eax ;	&#x2F;&#x2F;将 EAX 中的值减去 216</span><br></pre></td></tr></table></figure>

<h3 id="inc-dec-自增-自减"><a href="#inc-dec-自增-自减" class="headerlink" title="inc, dec 自增, 自减"></a><code>inc, dec</code> 自增, 自减</h3><p><code>inc</code> 指令让它的参数加 1, <code>dec</code> 指令则是让它的参数减去 1.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inc &lt;reg</span><br><span class="line">inc &lt;mem</span><br><span class="line">dec &lt;reg</span><br><span class="line">dec &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dec %eax ;		&#x2F;&#x2F;EAX 中的值减去 1</span><br><span class="line">incl var(,1) ;		&#x2F;&#x2F;将 var 所代表的 32 位整数加上 1.</span><br></pre></td></tr></table></figure>

<h3 id="imul-整数相乘"><a href="#imul-整数相乘" class="headerlink" title="imul 整数相乘"></a><code>imul</code> 整数相乘</h3><p><code>imul</code> 指令有两种基本格式 : 第一种是 2 个参数的 ( 看下面语法开始两条 ); 第二种格式是 3 个参数的 ( 看下面语法最后两条 ).</p>
<p>2 个参数的这种格式, <strong>先是将两个参数相乘, 然后把结果存到第二个参数中. 运算结果 ( 即第二个参数 ) 必须是一个寄存器.</strong></p>
<p>3 个参数的这种格式, <strong>先是将它的第 1 个参数和第 2 个参数相乘, 然后把结果存到第 3 个参数中, 当然, 第 3 个参数必须是一个寄存器. 此外, 第 1 个参数必须是一个常数.</strong></p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imul &lt;reg32, &lt;reg32</span><br><span class="line">imul &lt;mem, &lt;reg32</span><br><span class="line">imul &lt;con, &lt;reg32, &lt;reg32</span><br><span class="line">imul &lt;con, &lt;mem, &lt;reg32</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imul (%ebx), %eax ;		&#x2F;&#x2F;将 EAX 中的 32 位整数, 与 EBX 中的内容所指的内存单元, 相乘, 然后把结果存到 EAX 中.</span><br><span class="line">imul $25, %edi, %esi ;		&#x2F;&#x2F;ESI 被设置为 EDI * 25.</span><br></pre></td></tr></table></figure>

<h3 id="idiv-整数相除"><a href="#idiv-整数相除" class="headerlink" title="idiv 整数相除"></a><code>idiv</code> 整数相除</h3><p><strong><code>idiv</code>只有一个操作数，此操作数为除数，而被除数则为 EDX : EAX 中的内容（一个64位的整数）， 除法结果 ( 商 ) 存在 EAX 中, 而所得的余数存在 EDX 中.</strong></p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idiv &lt;reg32</span><br><span class="line">idiv &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idiv %ebx ;		&#x2F;&#x2F;用 EDX : EAX 的值除以 EBX 的值. 商存放在 EAX 中, 余数存放在 EDX 中.</span><br><span class="line">idivw (%ebx) ;		&#x2F;&#x2F;将 EDX : EAX 的值除以存储在 EBX 所对应内存单元的 32 位值. 商存放在 EAX 中, 余数存放在 EDX 中.</span><br></pre></td></tr></table></figure>

<h3 id="and-or-xor-按位逻辑-与-或-异或-运算"><a href="#and-or-xor-按位逻辑-与-或-异或-运算" class="headerlink" title="and, or, xor 按位逻辑 与, 或, 异或 运算"></a><code>and, or, xor</code> 按位逻辑 与, 或, 异或 运算</h3><p>这些指令分别对它们的参数进行相应的逻辑运算, <strong>运算结果存到第一个参数中.</strong></p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and &lt;reg, &lt;reg</span><br><span class="line">and &lt;mem, &lt;reg</span><br><span class="line">and &lt;reg, &lt;mem</span><br><span class="line">and &lt;con, &lt;reg</span><br><span class="line">and &lt;con, &lt;mem</span><br><span class="line"></span><br><span class="line">or &lt;reg, &lt;reg</span><br><span class="line">or &lt;mem, &lt;reg</span><br><span class="line">or &lt;reg, &lt;mem</span><br><span class="line">or &lt;con, &lt;reg</span><br><span class="line">or &lt;con, &lt;mem</span><br><span class="line"></span><br><span class="line">xor &lt;reg, &lt;reg</span><br><span class="line">xor &lt;mem, &lt;reg</span><br><span class="line">xor &lt;reg, &lt;mem</span><br><span class="line">xor &lt;con, &lt;reg</span><br><span class="line">xor &lt;con, &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and $0x0F, %eax ;		&#x2F;&#x2F;只留下 EAX 中最后 4 位数字 (二进制位)</span><br><span class="line">xor %edx, %edx ;		&#x2F;&#x2F;将 EDX 的值全部设置成 0</span><br></pre></td></tr></table></figure>

<h3 id="not-逻辑位运算-非"><a href="#not-逻辑位运算-非" class="headerlink" title="not 逻辑位运算 非"></a><code>not</code> 逻辑位运算 非</h3><p>对参数进行逻辑非运算, 即<strong>翻转参数中所有位的值</strong>.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">not &lt;reg</span><br><span class="line">not &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">not %eax ;		&#x2F;&#x2F;将 EAX 的所有值翻转.</span><br></pre></td></tr></table></figure>

<h3 id="neg-取负指令"><a href="#neg-取负指令" class="headerlink" title="neg 取负指令"></a><code>neg</code> 取负指令</h3><p>取参数的二进制补码负数. 直接看例子也许会更好懂.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neg &lt;reg</span><br><span class="line">neg &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neg %eax ;		&#x2F;&#x2F;EAX → -EAX</span><br></pre></td></tr></table></figure>

<h3 id="shl-shr-按位左移或者右移"><a href="#shl-shr-按位左移或者右移" class="headerlink" title="shl, shr 按位左移或者右移"></a><code>shl, shr</code> 按位左移或者右移</h3><p>这两个指令对第一个参数进行位运算, 移动的位数由第二个参数决定, <strong>移动过后的空位拿 0 补上</strong>.被移的参数最多可以被移 31 位. <strong>第二个参数可以是 8 位常数或者寄存器 CL. 在任意情况下, 大于 31 的移位都默认是与 32 取模</strong>.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shl &lt;con8, &lt;reg</span><br><span class="line">shl &lt;con8, &lt;mem</span><br><span class="line">shl %cl, &lt;reg</span><br><span class="line">shl %cl, &lt;mem</span><br><span class="line"></span><br><span class="line">shr &lt;con8, &lt;reg</span><br><span class="line">shr &lt;con8, &lt;mem</span><br><span class="line">shr %cl, &lt;reg</span><br><span class="line">shr %cl, &lt;mem</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shl $1, %eax ;		&#x2F;&#x2F;将 EAX 的值乘以 2 (如果最高有效位是 0 的话)</span><br><span class="line">shr %cl, %ebx ;		&#x2F;&#x2F;将 EBX 的值除以 2n, 其中 n 为 CL 中的值, 运算最终结果存到 EBX 中.</span><br></pre></td></tr></table></figure>

<h2 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h2><p>x86 处理器有一个<strong>指令指针寄存器 ( EIP )</strong>, 该寄存器为 32 位寄存器, 它用来在内存中指示我们<strong>输入汇编指令的位置.</strong> 就是说这个寄存器指向哪个内存单元, 那个单元存储的机器码就是程序执行的指令. 通常它是指向我们程序要执行的 下一条指令. <em>但是不能直接操作 EIP 寄存器, 你需要流程控制指令来隐式地给它赋值</em>.</p>
<p>我们**使用符号 <code>&lt;label</code> 来当作程序中的标签. 通过输入标签名称后跟冒号, 可以将标签插入 x86 汇编代码文本中的任何位置. **例如 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       mov 8(%ebp), %esi</span><br><span class="line">begin:</span><br><span class="line">       xor %ecx, %ecx</span><br><span class="line">       mov (%esi), %eax</span><br></pre></td></tr></table></figure>

<p>该代码片段中的第二段被套上了 “ begin “ 这个标签. <em>在代码的其它地方, 我们可以用 “ begin “ 这个标签从而更方便地来引用这段指令在内存中的位置. 这个标签只是用来更方便地表示位置的, 它并不是用来代表某个 32 位值.</em></p>
<h3 id="jmp-跳转指令"><a href="#jmp-跳转指令" class="headerlink" title="jmp 跳转指令"></a><code>jmp</code> 跳转指令</h3><p>将程序跳转到参数指定的内存地址, <strong>然后执行该内存地址的指令</strong>.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp &lt;label</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp begin ;		&#x2F;&#x2F;跳转到打了 &quot; begin &quot; 这个标签的地方</span><br></pre></td></tr></table></figure>

<h3 id="jcondition-有条件的跳转"><a href="#jcondition-有条件的跳转" class="headerlink" title="jcondition 有条件的跳转"></a><code>jcondition</code> 有条件的跳转</h3><p>这些指令是<strong>条件跳转指令</strong>, 它们基于一组条件代码的状态, <strong>这些条件代码的状态存放在称为机器状态字 ( machine status word ) 的特殊寄存器中</strong>. 机器状态字的内容包括关于最后执行的算术运算的信息. 例如, 这个字的一个位表示最后的结果是否为 0. 另一个位表示最后结果是否为负数. 基于这些条件代码, 可以执行许多条件跳转. 例如, 如果最后一次算术运算结果为 0, 则 <code>jz</code> 指令就是跳转到指定参数标签. 否则, 程序就按照流程进入下一条指令.</p>
<p>许多条件分支的名称都是很直观的, 这些指令的运行, 都和一个特殊的比较指令有关, <code>cmp</code>( 见下文 ). 例如, 像 <code>jle</code> 和 <code>jne</code> 这种指令, 它们首先对参数进行 <code>cmp</code> 操作.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">je &lt;label ;		&#x2F;&#x2F;当相等的时候跳转</span><br><span class="line">jne &lt;label ;	&#x2F;&#x2F;当不相等的时候跳转</span><br><span class="line">jz &lt;label ;		&#x2F;&#x2F;当最后结果为 0 的时候跳转</span><br><span class="line">jg &lt;label ;		&#x2F;&#x2F;当大于的时候跳转</span><br><span class="line">jge &lt;label ;	&#x2F;&#x2F;当大于等于的时候跳转</span><br><span class="line">jl &lt;label ;		&#x2F;&#x2F;当小于的时候跳转</span><br><span class="line">jle &lt;label ;	&#x2F;&#x2F;当小于等于的时候跳转</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp %ebx, %eax</span><br><span class="line">jle done ;		&#x2F;&#x2F;如果 EAX 的值小于等于 EBX 的值, 就跳转到 &quot; done &quot; 标签, 否则就继续执行下一条指令.</span><br></pre></td></tr></table></figure>

<h3 id="cmp-比较指令"><a href="#cmp-比较指令" class="headerlink" title="cmp 比较指令"></a><code>cmp</code> 比较指令</h3><p>比较两个参数的值, <strong>适当地设置机器状态字中的条件代码</strong>. 此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp &lt;reg, &lt;reg</span><br><span class="line">cmp &lt;mem, &lt;reg</span><br><span class="line">cmp &lt;reg, &lt;mem</span><br><span class="line">cmp &lt;con, &lt;reg</span><br></pre></td></tr></table></figure>

<ul>
<li><em>例子</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmpb $10, (%ebx)</span><br><span class="line">jeq loop ;		&#x2F;&#x2F;如果 EBX 的值等于整数常量 10, 则跳转到标签 &quot; loop &quot; 的位置.</span><br></pre></td></tr></table></figure>

<h3 id="call-ret-子程序调用与返回"><a href="#call-ret-子程序调用与返回" class="headerlink" title="call, ret 子程序调用与返回"></a><code>call, ret</code> 子程序调用与返回</h3><p>这两个指令<strong>实现子程序的调用和返回</strong>. <code>call</code> 指令首先将当前代码位置推到内存中硬件支持的栈内存上 ( 请看 <code>push</code> 指令 ), 然后<strong>无条件跳转到标签参数指定的代码位置</strong>. 与简单的 <code>jmp</code> 指令不同, <code>call</code> 指令保存了子程序完成时返回的位置. 就是 <strong><code>call</code> 指令结束后, 返回到调用之前的地址.</strong></p>
<p><code>ret</code> 指令<strong>实现子程序的返回.</strong> 该指令首先从栈中取出代码 ( 类似于 <code>pop</code> 指令 ). 然后它<strong>无条件跳转到检索到的代码位置</strong>.</p>
<ul>
<li><em>语法</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call &lt;label</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<h1 id="调用约定-Calling-Convention"><a href="#调用约定-Calling-Convention" class="headerlink" title="调用约定 Calling Convention"></a>调用约定 Calling Convention</h1><hr>
<p>为了方便不同的程序员去分享代码和运行库, 并简化一般子程序的使用, 程序员们通常会遵守一定的约定 ( Calling Convention ). 调用约定是关于如何从例程调用和返回的协议. 例如，给定一组调用约定规则，程序员不需要检查子例程的定义来确定如何将参数传递给该子例程. 此外，给定一组调用约定规则，可以使高级语言编译器遵循规则，从而允许手动编码的汇编语言例程和高级语言例程相互调用.</p>
<p>我们将讲解被广泛使用的 C 语言调用约定. 遵循此约定将允许您编写可从 C ( 和C ++ ) 代码安全地调用的汇编语言子例程, 并且还允许您从汇编语言代码调用 C 函数库.</p>
<p>C 调用约定很大程度上取决于使用硬件支持的栈内存. 它基于 <code>push</code>, <code>pop</code>, <code>call</code> 和 <code>ret</code> 指令. 子程序的参数在栈上传递. 寄存器保存在栈中, 子程序使用的局部变量放在栈中. 在大多数处理器上实现的高级过程语言都使用了类似的调用约定.</p>
<p>调用约定分为两组. 第一组规则是面向子例程的调用者 ( Caller ) 的, 第二组规则面向子例程的编写者, 即被调用者 ( Callee ). 应该强调的是, 错误地遵守这些规则会导致程序的致命错误, 因为栈将处于不一致的状态; 因此, 在你自己的子例程中实现调用约定的时候, 务必当心.</p>
<p><img src="/images/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80_stack-convention.png" alt="convention"></p>
<p>将调用约定可视化的一种好方法是, 在子例程执行期间画一个栈内存附近的图. 上图 描绘了在执行具有三个参数和三个局部变量的子程序期间栈的内容. 栈中描绘的单元都是 32 位内存单元, 因此这些单元的内存地址相隔 4 个字节. 第一个参数位于距基指针 8 个字节的偏移处. 在栈参数的上方 ( 和基指针下方 ), <code>call</code> 指令在这放了返回地址, 从而导致从基指针到第一个参数有额外 4 个字节的偏移量. 当 <code>ret</code> 指令用于从子程序返回时, 它将跳转到栈中的返回地址.</p>
<h2 id="调用者约定-Caller-Rules"><a href="#调用者约定-Caller-Rules" class="headerlink" title="调用者约定 Caller Rules"></a>调用者约定 Caller Rules</h2><p>要进行子程序调用，调用者应该：</p>
<ol>
<li>在调用子例程之前, 调用者应该保存指定调用者保存 ( Caller-saved )的某些寄存器的内容. 调用者保存的寄存器是 EAX, ECX, EDX. 由于被调用的子程序可以修改这些寄存器, 所以如果调用者在子例程返回后依赖这些寄存器的值, 调用者必须将这些寄存器的值入栈, 然后就可以在子例程返回后恢复它们.</li>
<li>要把参数传递给子例程, 你可以在调用之前把参数入栈. 参数的入栈顺序应该是反着的, 就是最后一个参数应该最先入栈. 随着栈内存地址增大, 第一个参数将存储在最低的地址, 在历史上, 这种参数的反转用于允许函数传递可变数量的参数.</li>
<li>要调用子例程, 请使用<code>call</code>指令. 该指令将返回地址存到栈上, 并跳转到子程序的代码. 这个会调用子程序, 这个子程序应该遵循下面的被调用者约定.</li>
</ol>
<p>子程序返回后 ( 紧跟调用指令后 ), 调用者可以期望在寄存器 EAX 中找到子例程的返回值. 要恢复机器状态 ( machine state ), 调用者应该 :</p>
<ol>
<li>从栈中删除参数, 这会把栈恢复到调用之前的状态.</li>
<li>把 EAX, ECX, EDX 之前入栈的内容给出栈, 调用者可以假设子例程没有修改其它寄存器.</li>
<li><strong>例子</strong></li>
</ol>
<p>下面的代码就是个活生生的例子, 它展示了遵循约定的函数调用. 调用者正在调用一个带有 3 个整数参数的函数 myFunc. 第一个参数是 EAX, 第二个参数是常数 216; 第三个参数位于 EBX 的值所代表的内存地址.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push (%ebx) ;	&#x2F;&#x2F;最后一个参数最先入栈</span><br><span class="line">push $216 ;		&#x2F;&#x2F;把第二个参数入栈</span><br><span class="line">push %eax ;		&#x2F;&#x2F;第一个参数最后入栈</span><br><span class="line"></span><br><span class="line">call myFunc ;	&#x2F;&#x2F;调用这个函数 ( 假设以 C 语言的模式命名 )</span><br><span class="line"></span><br><span class="line">add $12, %esp</span><br></pre></td></tr></table></figure>

<p>注意, 在调用返回后, 调用者使用 <code>add</code> 指令来清理栈内存. 我们栈内存中有 12 个字节 ( 3 个参数, 每个参数 4 个字节 ), 然后栈内存地址增大. 因此, 为了摆脱掉这些参数, 我们可以直接往栈里面加个 12.</p>
<p>myFunc 生成的结果现在可以有用于寄存器 EAX. 调用者保存 ( Caller-saved ) 的寄存器 ( ECX, EDX ) 的值可能已经被修改. 如果调用者在调用之后使用它们，则需要在调用之前将它们保存在堆栈中并在调用之后恢复它们. 说白了就是把栈这个玩意当作临时存放点.</p>
<h2 id="被调用者约定-Callee-Rules"><a href="#被调用者约定-Callee-Rules" class="headerlink" title="被调用者约定 Callee Rules"></a>被调用者约定 Callee Rules</h2><p>子例程的定义应该遵循子例程开头的以下规则 :</p>
<ul>
<li>1.将 EBP 的值入栈, 然后用下面的指示信息把 ESP 的值复制到 EBP 中 :</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov  %esp, %ebp</span><br></pre></td></tr></table></figure>

<p>这个初始操作保留了基指针 EBP. 按照约定, 基指针作为栈上找到参数和变量的参考点. 当子程序正在执行的时候, 基指针保存了从子程序开始执行是的栈指针值的副本. 参数和局部变量将始终位于远离基指针值的已知常量偏移处. 我们在子例程的开头推送旧的基指针值，以便稍后在子例程返回时为调用者恢复适当的基指针值. 记住, 调用者不希望子例程修改基指针的值. 然后我们把栈指针移动到 EBP 中, 以获取访问参数和局部变量的参考点.</p>
<ul>
<li>2.接下来, 通过在栈中创建空间来分配局部变量. 回想一下, 栈会向下增长, 因此要在栈顶部创建空间, 栈指针应该递减. 栈指针递减的数量取决于所需局部变量的数量和大小. 例如, 如果需要 3 个局部整数 ( 每个 4 字节 ), 则需要将堆栈指针递减 12, 从而为这些局部变量腾出空间 ( 即sub $12, %esp ). 和参数一样, 局部变量将位于基指针的已知偏移处.</li>
<li>3.接下来, 保存将由函数使用的 被调用者保存的 ( Callee-saved ) 寄存器的值. 要存储寄存器, 请把它们入栈. 被调用者保存 ( Callee-saved ) 的寄存器是 EBX, EDI 和 ESI ( ESP 和 EBP 也将由调用约定保留, 但在这个步骤中不需要入栈 ).</li>
</ul>
<p>在完成这 3 步之后, 子例程的主体可以继续. 返回子例程的时候, 必须遵循以下步骤 :</p>
<ol>
<li>将返回值保存在 EAX 中.</li>
<li>恢复已经被修改的任何被调用者保存 ( Callee-saved ) 的寄存器 ( EDI 和 ESI ) 的旧值. 通过出栈来恢复它们. 当然应该按照相反的顺序把它们出栈.</li>
<li>释放局部变量. 显而易见的法子是把相应的值添加到栈指针 ( 因为空间是通过栈指针减去所需的数量来分配的 ). 事实上呢, 解除变量释放的错误的方法是将基指针中的值移动到栈指针 : <code>mov %ebp, %esp</code>. 这个法子有效, 是因为基指针始终包含栈指针在分配局部变量之前包含的值.</li>
<li>在返回之前, 立即通过把 EBP 出栈来恢复调用者的基指针值. 回想一下, 我们在进入子程序的时候做的第一件事是推动基指针保存它的旧值.</li>
<li>最后, 通过执行 <code>ret</code> 指令返回. 这个指令将从栈中找到并删除相应的返回地址 ( call 指令保存的那个 ).</li>
</ol>
<p>请注意, 被调用者的约定完全被分成了两半, 简直是彼此的镜像. 约定的前半部分适用于函数开头, 并且通常被称为定义函数的<em>序言</em> ( <em>prologue</em> ) .这个约定的后半部分适用于函数结尾, 因此通常被称为定义函数的<em>结尾</em> ( epilogue ).</p>
<ul>
<li><strong>例子</strong></li>
</ul>
<p>这是一个遵循被调用者约定的例子 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;启动代码部分</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">;将 myFunc 定义为全局 ( 导出 ) 函数</span><br><span class="line">.globl myFunc</span><br><span class="line">.type myFunc, @function</span><br><span class="line">myFunc :</span><br><span class="line">;子程序序言</span><br><span class="line">push %ebp ;			&#x2F;&#x2F;保存基指针旧值</span><br><span class="line">mov %esp, %ebp ;	&#x2F;&#x2F;设置基指针新值</span><br><span class="line">sub $4, %esp ;		&#x2F;&#x2F;为一个 4 字节的变量腾出位置</span><br><span class="line">push %edi</span><br><span class="line">push %esi ;			&#x2F;&#x2F;这个函数会修改 EDI 和 ESI, 所以先给它们入栈</span><br><span class="line">;不需要保存 EBX, EBP 和 ESP</span><br><span class="line"></span><br><span class="line">;子程序主体</span><br><span class="line">mov 8(%ebp), %eax ;		&#x2F;&#x2F;把参数 1 的值移到 EAX 中</span><br><span class="line">mov 12(%ebp), %esi ;	&#x2F;&#x2F;把参数 2 的值移到 ESI 中</span><br><span class="line">mov 16(%ebp), %edi ;	&#x2F;&#x2F;把参数 3 的值移到 EDI 中</span><br><span class="line"></span><br><span class="line">mov %edi, -4(%ebp) ;	&#x2F;&#x2F;把 EDI 移给局部变量</span><br><span class="line">add %esi, -4(%ebp) ;	&#x2F;&#x2F;把 ESI 添加给局部变量</span><br><span class="line">add -4(%ebp), %eax ;	&#x2F;&#x2F;将局部变量的内容添加到 EAX ( 最终结果 ) 中</span><br><span class="line"></span><br><span class="line">;子程序结尾</span><br><span class="line">pop %esi ;		&#x2F;&#x2F;恢复寄存器的值</span><br><span class="line">pop %edi</span><br><span class="line">mov %ebp, %esp ;	&#x2F;&#x2F;释放局部变量</span><br><span class="line">pop %ebp ;		&#x2F;&#x2F;恢复调用者的基指针值</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>子程序序言执行标准操作, 即在 EBP ( 基指针 ) 中保存栈指针的副本, 通过递减栈指针来分配局部变量, 并在栈上保存寄存器的值.</p>
<p>在子例程的主体中, 我们可以看到基指针的使用. 在子程序执行期间, 参数和局部变量都位于与基指针的常量偏移处. 特别地, 我们注意到, 由于参数在调用子程序之前被放在栈中, 因此它们总是位于栈基指针 ( 即更高的地址 ) 之下. 子程序的第一个参数总是可以在内存地址 ( EBP+8 ) 找到, 第二个参数在 ( EBP+12 ), 第三个参数在 ( EBP+16). 类似地, 由于在设置基指针后分配局部变量, 因此它们总是位于栈上基指针 ( 即较低地址 ) 之上. 特别是, 第一个局部变量总是位于 ( EBP-4 ), 第二个位于 ( EBP-8 ), 以此类推. 这种基指针的常规使用, 让我们可以快速识别函数内部局部变量和参数的使用.</p>
<p>函数结尾基本上是函数序言的镜像. 从栈中恢复调用者的寄存器值, 通过重置栈指针来释放局部变量, 恢复调用者的基指针值, 并用 <code>ret</code> 指令返回调用者中的相应代码位置, 从哪来回哪去.</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">维基百科 X86 调用约定</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Aloof77">Aloof</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://aloof77.github.io">https://aloof77.github.io</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Aloof所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Reverse/">Reverse</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a><a class="post-meta__tags" href="/tags/x86/">x86</a></div><div class="post_share"><div class="social-share" data-image="/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/font.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/20/Re_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"><img class="prev-cover" src="/2021/03/20/Re_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/font.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Re_常用操作</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="/2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/font.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Re_C/C++语言基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/25/Re_x64汇编基础/" title="Re_x64汇编基础"><img class="cover" src="/2021/03/25/Re_x64%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/font.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-25</div><div class="title">Re_x64汇编基础</div></div></a></div><div><a href="/2021/03/25/Reverse/" title="Reverse"><img class="cover" src="/2021/03/25/Reverse/font.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-25</div><div class="title">Reverse</div></div></a></div><div><a href="/2021/03/29/从0到1_逆向学习/" title="从0到1_逆向学习"><img class="cover" src="/2021/03/29/%E4%BB%8E0%E5%88%B01_%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/font.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-29</div><div class="title">从0到1_逆向学习</div></div></a></div><div><a href="/2021/03/20/Re_常用操作/" title="Re_常用操作"><img class="cover" src="/2021/03/20/Re_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/font.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">Re_常用操作</div></div></a></div><div><a href="/2021/03/28/脱壳/" title="脱壳"><img class="cover" src="/2021/03/28/%E8%84%B1%E5%A3%B3/font.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-28</div><div class="title">脱壳</div></div></a></div><div><a href="/2021/03/16/Re_c语言基础/" title="Re_C/C++语言基础"><img class="cover" src="/2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/font.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-16</div><div class="title">Re_C/C++语言基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-Registers"><span class="toc-number">1.</span> <span class="toc-text">寄存器 Registers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F-Memory-and-Addressing-Modes"><span class="toc-number">2.</span> <span class="toc-text">内存和寻址模式 Memory and Addressing Modes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.1.</span> <span class="toc-text">声明静态数据区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.</span> <span class="toc-text">内存寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%90%8E%E7%BC%80"><span class="toc-number">2.3.</span> <span class="toc-text">操作后缀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4-Instructions"><span class="toc-number">3.</span> <span class="toc-text">指令 Instructions</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">数据移动指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mov-%E7%A7%BB%E5%8A%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">mov 移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-%E5%85%A5%E6%A0%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">push 入栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop-%E5%87%BA%E6%A0%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">pop 出栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lea%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.4.</span> <span class="toc-text">lea加载有效地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">逻辑运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#add-%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">3.2.1.</span> <span class="toc-text">add 整数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sub-%E6%95%B4%E6%95%B0%E7%9B%B8%E5%87%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">sub 整数相减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inc-dec-%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">inc, dec 自增, 自减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#imul-%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-number">3.2.4.</span> <span class="toc-text">imul 整数相乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#idiv-%E6%95%B4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">3.2.5.</span> <span class="toc-text">idiv 整数相除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#and-or-xor-%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91-%E4%B8%8E-%E6%88%96-%E5%BC%82%E6%88%96-%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.6.</span> <span class="toc-text">and, or, xor 按位逻辑 与, 或, 异或 运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#not-%E9%80%BB%E8%BE%91%E4%BD%8D%E8%BF%90%E7%AE%97-%E9%9D%9E"><span class="toc-number">3.2.7.</span> <span class="toc-text">not 逻辑位运算 非</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#neg-%E5%8F%96%E8%B4%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.8.</span> <span class="toc-text">neg 取负指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shl-shr-%E6%8C%89%E4%BD%8D%E5%B7%A6%E7%A7%BB%E6%88%96%E8%80%85%E5%8F%B3%E7%A7%BB"><span class="toc-number">3.2.9.</span> <span class="toc-text">shl, shr 按位左移或者右移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">流程控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">jmp 跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jcondition-%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%B7%B3%E8%BD%AC"><span class="toc-number">3.3.2.</span> <span class="toc-text">jcondition 有条件的跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmp-%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">cmp 比较指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-ret-%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="toc-number">3.3.4.</span> <span class="toc-text">call, ret 子程序调用与返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-Calling-Convention"><span class="toc-number">4.</span> <span class="toc-text">调用约定 Calling Convention</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%80%85%E7%BA%A6%E5%AE%9A-Caller-Rules"><span class="toc-number">4.1.</span> <span class="toc-text">调用者约定 Caller Rules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E7%BA%A6%E5%AE%9A-Callee-Rules"><span class="toc-number">4.2.</span> <span class="toc-text">被调用者约定 Callee Rules</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/back.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 By Aloof</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Happy every day and night!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="听党指挥,能打胜仗,作风优良" data-fontsize="15px" data-random="false" async="async"></script><script>((window.gitter = {}).chat = {}).options = {
  disableDefaultChat: true,
};
document.addEventListener('gitter-sidecar-ready', (e) => {
  const GitterChat = e.detail.Chat
  let chat

  function initGitter () {
    chat = new GitterChat({
      room: 'Aloof77/community',
      activationElement: '#chat_btn'
    });
  }

  initGitter()

  if (false) {
    document.addEventListener('pjax:complete', () => {
      chat.destroy()
      initGitter()
    })
  }

})</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>