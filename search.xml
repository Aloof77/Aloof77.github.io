<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从0到1_逆向学习</title>
      <link href="2021/03/29/%E4%BB%8E0%E5%88%B01_%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/29/%E4%BB%8E0%E5%88%B01_%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逆向工程基础"><a href="#逆向工程基础" class="headerlink" title="逆向工程基础"></a>逆向工程基础</h1><hr><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>CTF中逆向工程的题目形式一般为：程序接收用户的一个输入，并在程序中进行一系列<strong>校验算法</strong>，如果通过校验则提示成功，此时的输入即flag，<strong>研究的是程序的行为和算法</strong>.</p><p>要注意的是，这些校验算法可以是已经成熟的加解密方案，也可以是作者自创的某种算法.</p><h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><hr><h3 id="可执行文件的形成过程"><a href="#可执行文件的形成过程" class="headerlink" title="可执行文件的形成过程"></a>可执行文件的形成过程</h3><p><a href="https://aloof77.github.io/2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/#%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">从源代码到可执行文件的过程</a></p><h3 id="不同格式的可执行文件"><a href="#不同格式的可执行文件" class="headerlink" title="不同格式的可执行文件"></a>不同格式的可执行文件</h3><p>Windows系统使用的是PE可执行文件，Linux系统使用的是ELF可执行文件，这两种可执行文件格式都是由COFE格式发展而来的.</p><h4 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h4><p>由DOS头、PE文件头、节表及各节数据组成；如果引用外部动态链接库，则有导入表；如果提供函数给其他程序来动态链接(DLL文件)，则有导出表.</p><h4 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h4><p>由ELF头、各节数据、节表、字符串段、符号表组成.</p><h4 id="节-Section"><a href="#节-Section" class="headerlink" title="节(Section)"></a>节(Section)</h4><p>节是程序中各部分的逻辑划分，一般有特定名称，如.text或.code代表代码节、.data代表数据节等.</p><h2 id="汇编语言基本知识"><a href="#汇编语言基本知识" class="headerlink" title="汇编语言基本知识"></a>汇编语言基本知识</h2><hr><h3 id="寄存器、内存和寻址"><a href="#寄存器、内存和寻址" class="headerlink" title="寄存器、内存和寻址"></a>寄存器、内存和寻址</h3><p>寄存器(Register)是CPU的组成部分，是又咸存储容量的告诉存储部件，用来暂存指令、数据和地址.</p><h4 id="X86寄存器"><a href="#X86寄存器" class="headerlink" title="X86寄存器"></a>X86寄存器</h4><table><thead><tr><th align="center"><strong>通用寄存器</strong></th><th align="center"><strong>EAX</strong></th><th align="center"><strong>EBX</strong></th><th align="center"><strong>ECX</strong></th><th align="center"><strong>EDX</strong></th><th align="center"><strong>ESI</strong></th><th align="center"><strong>EDI</strong></th></tr></thead><tbody><tr><td align="center"><strong>栈顶指针寄存器</strong></td><td align="center"><strong>ESP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>栈底指针寄存器</strong></td><td align="center"><strong>EBP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>指令计数器</strong></td><td align="center"><strong>EIP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>段寄存器</strong></td><td align="center"><strong>CS</strong></td><td align="center"><strong>DS</strong></td><td align="center"><strong>SS</strong></td><td align="center"><strong>ES</strong></td><td align="center"><strong>FS</strong></td><td align="center"><strong>GS</strong></td></tr></tbody></table><h4 id="X86-64寄存器"><a href="#X86-64寄存器" class="headerlink" title="X86-64寄存器"></a>X86-64寄存器</h4><table><thead><tr><th align="center">通用寄存器</th><th align="center">RAX</th><th align="center">RBX</th><th align="center">RCX</th><th align="center">RDX</th><th align="center">RSI</th><th align="center">RDI</th><th>R8-R15</th></tr></thead><tbody><tr><td align="center"><strong>栈顶指针寄存器</strong></td><td align="center"><strong>RSP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center"><strong>栈底指针寄存器</strong></td><td align="center"><strong>RBP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center"><strong>指令计数器</strong></td><td align="center"><strong>RIP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center"><strong>段寄存器</strong></td><td align="center"><strong>CS</strong></td><td align="center"><strong>DS</strong></td><td align="center"><strong>SS</strong></td><td align="center"><strong>ES</strong></td><td align="center"><strong>FS</strong></td><td align="center"><strong>GS</strong></td><td></td></tr></tbody></table><p>其中，通用寄存器可拆分使用.</p><h4 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h4><table><thead><tr><th align="center"><strong>通用寄存器</strong></th><th align="center"><strong>AX</strong></th><th align="center"><strong>BX</strong></th><th align="center"><strong>CX</strong></th><th align="center"><strong>DX</strong></th><th align="center"><strong>SI</strong></th><th align="center"><strong>DI</strong></th></tr></thead><tbody><tr><td align="center"><strong>栈顶指针寄存器</strong></td><td align="center"><strong>SP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>栈底指针寄存器</strong></td><td align="center"><strong>BP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>指令计数器</strong></td><td align="center"><strong>IP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>段寄存器</strong></td><td align="center"><strong>CS</strong></td><td align="center"><strong>DS</strong></td><td align="center"><strong>SS</strong></td><td align="center"><strong>ES</strong></td><td align="center"><strong>FS</strong></td><td align="center"><strong>GS</strong></td></tr></tbody></table><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><table><thead><tr><th align="center"><strong>AF：辅助进位标志</strong></th><th align="center">当运算结果在第3位进位的时候置1</th></tr></thead><tbody><tr><td align="center"><strong>PF：奇偶校验标志</strong></td><td align="center"><strong>当运算结果的最低有效字节有偶数个1时置1</strong></td></tr><tr><td align="center"><strong>SF：符号标志</strong></td><td align="center"><strong>有符号整形的符号位为1时置1，代表这是一个负数</strong></td></tr><tr><td align="center"><strong>ZF：零标志</strong></td><td align="center"><strong>当运算结果全为0时置1</strong></td></tr><tr><td align="center"><strong>OF：溢出标志</strong></td><td align="center"><strong>运算结果在被操作数是有符号数且溢出时置1</strong></td></tr><tr><td align="center"><strong>CF：进位标志</strong></td><td align="center"><strong>运算结果向最高位以上进位时置1，用来判断无符号数的溢出</strong></td></tr></tbody></table><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p>寄存器**[]<strong>相当于C语言中的</strong>***运算符(间接访问).</p><p>间接寻址、基址寻址、变址寻址、基址加变址寻址</p><h3 id="x86-x64汇编语言"><a href="#x86-x64汇编语言" class="headerlink" title="x86/x64汇编语言"></a>x86/x64汇编语言</h3><p><strong>基本格式：操作码 [操作数1] [操作数2]</strong></p><table><thead><tr><th align="center">指令类型</th><th align="center">操作码</th><th align="center">指令实例</th><th align="center">对应作用</th></tr></thead><tbody><tr><td align="center">数据传送指令</td><td align="center">mov</td><td align="center">mov rax,rbx</td><td align="center">rax=rbx</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">mov qword[rdi],rax</td><td align="center">*(rdi)=rax</td></tr><tr><td align="center">取地址指令</td><td align="center">lea</td><td align="center">lea rax,[rsi]</td><td align="center">rax=&amp;*(rsi)</td></tr><tr><td align="center">算术运算指令</td><td align="center">add</td><td align="center">add rax,rbx</td><td align="center">rax+=rbx</td></tr><tr><td align="center"></td><td align="center">add</td><td align="center">add qword ptr[rdi],rax</td><td align="center">*(rdi)+=rax</td></tr><tr><td align="center"></td><td align="center">sub</td><td align="center">sub rax,rbx</td><td align="center">rax-=rbx</td></tr><tr><td align="center">逻辑运算指令</td><td align="center">and</td><td align="center">and rax,rbx</td><td align="center">rax&amp;=rbx</td></tr><tr><td align="center"></td><td align="center">xor</td><td align="center">xor rax,rbx</td><td align="center">rax^=rbx</td></tr><tr><td align="center">函数调用指令</td><td align="center">call</td><td align="center">call 0x401000</td><td align="center">执行0x401000地址函数</td></tr><tr><td align="center">函数返回指令</td><td align="center">ret</td><td align="center">ret</td><td align="center">函数返回</td></tr><tr><td align="center">比较指令</td><td align="center">cmp</td><td align="center">cmp rax,rbx</td><td align="center">根据rax与rbx比较的结果改变标志位</td></tr><tr><td align="center">无条件跳转指令</td><td align="center">jmp</td><td align="center">jmp 0x401000</td><td align="center">跳转到0x401000地址处</td></tr><tr><td align="center">栈操作指令</td><td align="center">push</td><td align="center">push rax</td><td align="center">将rax的值压入栈中</td></tr><tr><td align="center"></td><td align="center">pop</td><td align="center">pop rax</td><td align="center">从栈上弹出一个元素放入rax</td></tr></tbody></table><p>​    常见的条件跳转指令</p><table><thead><tr><th align="center">指令</th><th align="center">cmp a,b 条件</th><th align="center">flag 条件</th></tr></thead><tbody><tr><td align="center">jz/je</td><td align="center">a = b</td><td align="center">ZF = 1</td></tr><tr><td align="center">jnz/jne</td><td align="center">a != b</td><td align="center">ZF = 0</td></tr><tr><td align="center">jb/jnae/jc</td><td align="center">a &lt; b，无符号数</td><td align="center"></td></tr><tr><td align="center">ja/jnbe</td><td align="center">a &gt; b，无符号数</td><td align="center"></td></tr><tr><td align="center">jna/jbe</td><td align="center">a &lt;= b，无符号数</td><td align="center"></td></tr><tr><td align="center">jnc/jnb/jae</td><td align="center">a &gt;= b，无符号数</td><td align="center">CF = 0</td></tr><tr><td align="center">jg/jnle</td><td align="center">a &gt; b，有符号数</td><td align="center"></td></tr><tr><td align="center">jge/jnl</td><td align="center">a &gt;= b，有符号数</td><td align="center"></td></tr><tr><td align="center">jl/jnge</td><td align="center">a &lt; b，有符号数</td><td align="center"></td></tr><tr><td align="center">jle/jng</td><td align="center">a &lt;= b，有符号数</td><td align="center"></td></tr><tr><td align="center">jo</td><td align="center"></td><td align="center">OF = 1</td></tr><tr><td align="center">js</td><td align="center"></td><td align="center">SF = 1</td></tr></tbody></table><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>将机器语言翻译回汇编语言的过程称为反汇编</p><p>两种反汇编算法：</p><ul><li>线性扫描反汇编算法</li><li>递归下降反汇编算法</li></ul><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><h4 id="x86-32位架构的调用约定"><a href="#x86-32位架构的调用约定" class="headerlink" title="x86 32位架构的调用约定"></a>x86 32位架构的调用约定</h4><p>__cdecl：参数从右向左依次压入栈中，调用完毕，由调用者负责将这些压入的参数清理掉，返回值置于EAX中.绝大多数x86平台的C语言程序都在使用这种约定.</p><p>__stdcall：参数同样从右向左依次压入栈中，调用完毕，由被调用者负责清理压入的参数，返回值同样置于EAX中.Windows的很多API都是用这种方式提供的.</p><p>__thiscall：为类方法专门优化的调用约定，将类方法的this指针放在ECX寄存器中，然后将其余参数压入栈中.</p><p>__fastcall：为加速调用而生的调用约定，将第1个参数放在ECX中，将第2个参数放在EDX中，然后将后续的参数从右至左压入栈中.</p><h4 id="x86-64位架构的调用约定"><a href="#x86-64位架构的调用约定" class="headerlink" title="x86 64位架构的调用约定"></a>x86 64位架构的调用约定</h4><p>Microsoft x64位(x86-64)调用约定：在Windows上使用，依次(从左至右)将前4个参数放入RCX、RDX、R8、R9这4个寄存器，然后将剩下的参数从右至左压入栈中.</p><p>SystemV x64调用约定：在Linux、MacOS上使用，比Microsoft的版本多了两个寄存器，使用RDI、RSI、RDX、RCD、R8、R9这6个寄存器传递前6个参数，剩下的从右至左压栈.</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量被存放在栈上，在每次函数被调用时，程序从栈上分配一段空间，作为存储变量的区域.每个函数在被调用时都会产生这样的局部变量的区域、存储返回地址的区域和参数的区域.程序一层层地深入调用函数，每个函数自己的区域就一层层地叠在栈上.</p><p>每个函数自己的这一片区域称为<strong>帧</strong>，由于这些帧都在栈上，所有又被称为<strong>栈帧</strong>.站的内容随着进栈和出战回一直不断变化，但是一个函数中每个局部变量相对于该函数栈帧的偏移都是固定的，所以可以引入一个寄存器来专门存储当前栈帧的位置，即<strong>ebp</strong>，称为<strong>帧指针</strong>.</p><p>程序在函数初始化阶段赋值ebp为栈帧中间的某个位置，这样可以用ebp引用所有的函数变量.由于上一层的父函数也要使用ebp，因此在函数开始时先保存ebp，在赋值ebp为自己的栈帧的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure><p>现在每个函数的栈帧便由局部变量、父栈帧的值、返回地址、参数四部分构成.可以看出，ebp在初始化后实际上指向的时父栈帧地址的存储位置，因此，*ebp形成了一个链表，代表一层层的函数调用链.</p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><hr><ul><li><p>IDA pro</p></li><li><p>OllyDbg和x64dbg</p></li><li><p>GNU Binary Utilities</p><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">as</td><td align="center">汇编器</td></tr><tr><td align="center">ld</td><td align="center">链接器</td></tr><tr><td align="center">gprof</td><td align="center">性能分析工具程序</td></tr><tr><td align="center">addr2line</td><td align="center">从目标文件的虚拟地址获取文件的行号或符号</td></tr><tr><td align="center">ar</td><td align="center">可以对静态库进行船舰、修改和取出操作</td></tr><tr><td align="center">c++filt</td><td align="center">解码C++语言的符号</td></tr><tr><td align="center">dlltool</td><td align="center">创建Windows动态库</td></tr><tr><td align="center">gold</td><td align="center">另一种链接器</td></tr><tr><td align="center">nlmconv</td><td align="center">可以转换成NetWare Loadable Module目标文件格式</td></tr><tr><td align="center">nm</td><td align="center">显示目标文件内的符号</td></tr><tr><td align="center">objcopy</td><td align="center">复制目标文件，过程中可以修改</td></tr><tr><td align="center">objdump</td><td align="center">显示目标文件的相关信息，亦可反编译</td></tr><tr><td align="center">ranlib</td><td align="center">产生静态库的索引</td></tr><tr><td align="center">readelf</td><td align="center">显示ELF文件的内容</td></tr><tr><td align="center">size</td><td align="center">列出总体和Section的大小</td></tr><tr><td align="center">strings</td><td align="center">列出任何二进制的可显示字符串</td></tr><tr><td align="center">strip</td><td align="center">从目标文件中移除符号</td></tr><tr><td align="center">windmc</td><td align="center">产生Windows消息资源</td></tr><tr><td align="center">windres</td><td align="center">Windows资源编译器</td></tr></tbody></table></li><li><p>GDB</p></li></ul><h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><hr><hr><h2 id="IDA使用入门"><a href="#IDA使用入门" class="headerlink" title="IDA使用入门"></a>IDA使用入门</h2><hr><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><h3 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h3><ul><li><p>导航栏：显示程序的不同类型数据(普通函数、未定义函数的代码、数据、未定义等)的分布情况.</p></li><li><p>反汇编的主窗口：显示反汇编的结果、控制流图等，可以进行拖动、选择等操作.</p></li><li><p>函数窗口：显示所有的函数名称和地址(拖动下方滚动条即可查看到)，可以通过Ctrl+F组和键进行筛选.</p></li><li><p>输出窗口:显示运行过程中IDA的日志，也可以在下方的输入框中输入命令并执行.</p></li><li><p>状态指示器：显示为“AU:idle”即代表IDA已经完成了对程序的自动化分析.</p></li></ul><p>在反汇编窗口中，使用友间菜单或者快捷键空格可以在控制流图和文本界面反汇编间切换.</p><h3 id="数据类型操作"><a href="#数据类型操作" class="headerlink" title="数据类型操作"></a>数据类型操作</h3><p><strong>低版本的IDA没有撤销功能</strong></p><p><strong>定义数据类型的快捷键</strong></p><ul><li>U（Undefine）键：即取消一个地方已有的数据类型定义，此时会弹出确认的对话框，单击”Yes”按钮即可.</li><li>D（Data）键：即让某一个位置变成数据.一直按D键，这个位置的数据类型将会以1字节（byte/db）、2字节（word/dw）、4字节（dword/dd）、8字节（qword/dp）进行循环.IDA为了防止误操作，如果定义数据的操作会影响到已经有数据类型的位置，IDA会弹出确认的对话框；如果操作的位置及其附近完全是Undefined，则不会弹出确认对话框.</li><li>C（Code）键：既让某一个位置变为指令.确认对话框的弹出时机也与D键类似.在定义为指令后，IDA会自动以此为起始位置进行递归下降反汇编.</li></ul><p><strong>数据类型</strong></p><ul><li>A（ASCII）键：会以该位置为起点定义一个以”\0“结尾的字符串类型.</li><li>*键：将此处定义为一个数组，此时弹出一个对话框，用来设置数组的属性.</li><li>O（Offset）键：即将此处定义为一个地址偏移.</li></ul><h3 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h3><p><strong>处理函数的操作</strong></p><ul><li>删除函数：在函数窗口中选中函数后，按Delete键.</li><li>定义函数：在反汇编窗口中选中对应行后，按P键.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脱壳</title>
      <link href="2021/03/28/%E8%84%B1%E5%A3%B3/"/>
      <url>2021/03/28/%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="保护壳简介"><a href="#保护壳简介" class="headerlink" title="保护壳简介"></a>保护壳简介</h1><hr><h2 id="认识壳是什么"><a href="#认识壳是什么" class="headerlink" title="认识壳是什么"></a>认识壳是什么</h2><p><strong>壳</strong>是在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序.</p><p>它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务.</p><p><img src="/images/%E8%84%B1%E5%A3%B3_1.png" alt="what_is_pack"></p><p>由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，就把这样的程序称为<strong>壳</strong>了.</p><h2 id="壳的分类"><a href="#壳的分类" class="headerlink" title="壳的分类"></a>壳的分类</h2><p>我们通常将<strong>壳</strong>分为两类，一类是压缩壳，另一类是加密壳.</p><h3 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h3><p>压缩壳早在DOS时代就已经出现了，但是当时因为计算能力有限，解压开销过大，并没有得到广泛的运用.</p><p>使用压缩壳可以帮助缩减PE文件的大小，隐藏了PE文件内部代码和资源，便于网络传输和保存.</p><p>通常压缩壳有两类用途，一种只是单纯用于压缩普通PE文件的压缩壳，而另一种则会对源文件进行较大变形，严重破坏PE文件头，经常用于压缩恶意程序.</p><p>常见的压缩壳有：Upx、ASpack、PECompat</p><h3 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h3><p>加密壳或称保护壳，应用有多种防止代码逆向分析的技术，它最主要的功能是保护PE免受代码逆向分析.</p><p>由于加密壳的主要目的不再是压缩文件资源，所以加密壳保护的PE程序通常比原文件大得多.</p><p>目前加密壳大量用于对安全性要求高，对破解敏感得应用程序，同时也有恶意程序用于避免(降低)杀毒软件得检测查杀.</p><p>常见的加密壳有：ASProtector、Armadillo、EXECryptor、Themida、VMProtect</p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
          <category> 脱壳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> 脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统漫游</title>
      <link href="2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
      <url>2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本内容以c语言为基础</p><hr><hr><p><strong>计算机系统</strong>是由硬件和系统软件组成的，它们共同工作来运行应用程序.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过跟踪hello程序的生命周期来开始系统的学习.</p><h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>hello程序的生命周期是从一个<strong>源程序</strong>(或者说是<strong>源文件</strong>)开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c</p><p>源程序实际上就是一个由值0和1组成的位(又称为比特)序列，8个位被组织成一组，称为<strong>字节</strong>.每个字节表示程序中的某些文本字符.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-1.png" alt="hello.c的ASCII文本表示"></p><p>像hello.c这样只由ASCII字符构成的文件称为<strong>文本文件</strong>，所有其他文件都称为<strong>二进制文件</strong>.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-2.png" alt="ASCII码"></p><p>hello.c的表示方法说明了一个基本思想：系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的.<strong>区分不同数据对象的唯一方法是我们读到这些数据对象的上下文.</strong></p><h1 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h1><p>hello程序的生命周期是从一个可被人读懂的高级C语言程序开始的，为了能够在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列低级<strong>机器语言</strong>指令，然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打包，并以二进制磁盘文件的形式存放起来.目标程序也称为<strong>可执行目标文件</strong>.</p><p>在Unix系统上，从源文件到目标文件的转化是由<strong>编译器驱动程序</strong>完成的：</p><p><code>linxu&gt; gcc -o hello hello.c</code></p><p>在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello.这个编译过程可分为四个阶段完成，执行这四个阶段的程序(<strong>预处理器</strong>、<strong>编译器</strong>、<strong>汇编器</strong>和<strong>链接器</strong>)一起构成了<strong>编译系统</strong>.从源代码到可执行文件的<a href="https://aloof77.github.io/2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/#%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">相关学习笔记</a>.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-3.png" alt="编译系统"></p><ul><li><p>预处理阶段    预处理器(cpp)根据以字符<code>#</code>开头的命令，修改原始的C程序，结果得到了另一个C程序，通常以<code>.i</code>作为文件扩展名.</p></li><li><p>编译阶段    编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个<strong>汇编语言程序</strong>.该程序包含函数main的定义，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">subq$8, %rsp</span><br><span class="line">movl$.LCO, %edi</span><br><span class="line">callputs</span><br><span class="line">movl$0, %eax</span><br><span class="line">addq$8, %rsp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></li><li><p>汇编阶段    汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式，并将结果保存在目标文件hello.o中.hello.o是一个二进制文件，它包含的17个字节是函数main的指令编码.</p></li><li><p>链接阶段    链接器(ld)负责处理<code>.o</code>文件的合并.helllo程序调用了printf函数，它是每个C编译器都提供的<strong>标准C库</strong>中的一个函数，printf函数存在于一个名位printf.o的单独的预编译好了的目标文件中，这个文件必须合并到hello.o程序中，结果得到了hello文件，它是一个<strong>可执行目标文件</strong>(或者简称为<strong>可执行文件</strong>)，可以被加载到内存中，由系统执行.</p></li></ul><h1 id="了解编译系统如何工作是大有益处的"><a href="#了解编译系统如何工作是大有益处的" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h1><p>主要内容在后续将会学习，这里只做一个概述.</p><ul><li>优化程序性能</li><li>理解链接时出现的错误</li><li>避免安全漏洞</li></ul><h1 id="处理器读并解释储存在内存中的指令"><a href="#处理器读并解释储存在内存中的指令" class="headerlink" title="处理器读并解释储存在内存中的指令"></a>处理器读并解释储存在内存中的指令</h1><p>hello.c源程序已经被编译系统翻译成了可执行目标文件hello，并被存放在磁盘上.要想再Unix系统上运行该可执行文件，将它的文件名输入到称为<code>shell</code>的应用程序中：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">linux&gt; ./hello</span><br><span class="line">hello, world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure><p>shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令.如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件.</p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-4.png" alt="一个典型系统的硬件组成"></p><p><em>CPU：中央处理单元    ALU：算术/逻辑单元    PC：程序计数器    USB：通用串行总线</em></p><ol><li><p>总线    贯穿整个系统的是一组电子管道，称作<strong>总线</strong>，它携带信息字节并负责在各个部件间传递.通常总线被设计成传送定长的字节快，也就是<strong>字</strong>.字中的字节数(即<strong>字长</strong>)是一个基本的系统参数，现在的大多数机器字长要么是4个字节(32位)，要么是8个字节(64位).</p></li><li><p>I/O设备    I/O(输入/输出)设备是系统与外部世界的联系通道.四个常见I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(简单的说就是磁盘).最开始，可执行程序hello就存放在磁盘上.</p><p>每个I/O设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与I/O总线相连.控制器和适配器之间的区别主要在于它们的封装方式：控制器是I/O设备本身或者系统的主印刷电路板(通常称作<strong>主板</strong>)上的芯片组；而适配器则是一块插在主板插槽上的卡.功能都一样是再I/O总线和I/O设备之间传递信息.</p></li><li><p>主存    <strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">物理上：主存是由一组 动态随机存取存储器 (DRAM) 芯片组成的</span><br><span class="line">逻辑上：存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的.</span><br></pre></td></tr></table></figure><p>一般来说，组成程序的每条机器指令都由不同数量的字节构成，与C程序变量相对应的数据项的大小是根据类型变化的.如：</p><table><thead><tr><th align="center">类型</th><th align="center">字节数</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td></tr><tr><td align="center">float</td><td align="center">7</td></tr><tr><td align="center">long</td><td align="center">8</td></tr><tr><td align="center">double</td><td align="center">8</td></tr></tbody></table></li><li><p>处理器    <strong>中央处理单元(CPU)<strong>，简称</strong>处理器</strong>，是解释(或<strong>执行</strong>)存储主存中指令的引擎.处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>)，称为<strong>程序计数器(PC)</strong>.在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址).</p><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令处理器<strong>看上去</strong>是按照一个非常简单的指令执行模型来操作的，这个模型是由<a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84/7029547?fr=aladdin"><strong>指令集架构</strong></a>决定的.在这个模型中，指令按照严格的舒徐执行，而执行一条指令包含一系列的步骤.处理器从程序计数器指向的内存出读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻.</p><p>这样的简单操作并不多，它们围绕着主存、<strong>寄存器</strong>文件(register file)和**算数/逻辑单元(ALU)**进行.寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有为一个名字，ALU计算新的数据和地址值.下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作：</p><ul><li>加载：从贮存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容.</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容.</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容.</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值.</li></ul><p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行，因此将处理器的指令集架构和<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%9E%B6%E6%9E%84/10506659"><strong>微体系结构</strong></a>区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的.</p></li></ol><h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p>初始时，shell程序执行它的指令，等待我们输入一个指令.当我们在键盘上输入字符串”./hello”后，shell程序将字符逐一读入寄存器，再把它放到内存中.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-5.png" alt="从键盘上读取hello命令"></p><p> 当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入.然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存，数据包括最终会被输出的字符串”hello, world\n”.</p><p>利用<strong>直接存储器</strong>存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-6.png" alt="从磁盘加载可执行文件到主存"></p><p>一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令.这些指令将”hello, world\n”字符串中的自劫从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-7.png" alt="将输出字符串从存储器写道显示器"></p><h1 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h1><p>针对处理器和主存之间读取速度的巨大差异，系统设计者采用了更小更快的存储设备，称为**高速缓存存储器(简称为cahe或高速缓存)**，作为暂时的集结区域，存放处理器近期可能会需要的信息.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-8.png" alt="高速缓存存储器"></p><p>位于处理器芯片上的L1<strong>高速缓存</strong>的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快.一个容量为数十万到数百万字节的更大的L2<strong>高速缓存</strong>通过一条特殊的总线连接到处理器.进程访问L2高速缓存的时间要比访问L1高速缓存的时间长8倍，但是这仍然比访问主存的时间快5~10倍.L1和L2高速缓存使用一种叫做<strong>静态随机访问存储器(SRAM)<strong>的硬件技术实现的.比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和L3.系统可以获得一个很大的存储器，同时访问速度也很快，原因时利用了高速缓存的</strong>局部性</strong>原理，即程序具有访问局部区域里的数据和代码的趋势.通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成.</p><p>可以发现利用高速缓存能将程序的性能提高一个数量级.</p><h1 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h1><p>在处理器和一个较大较慢的设备之间插入一个更小更快的存储设备的想法已经称为一个普遍的观念.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-9.png" alt="一个存储器层次结构的示例"></p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存.</p><h1 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h1><p>可以把<strong>操作系统</strong>看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-10.png" alt="计算机系统的分层视图"></p><p>操作系统有两个基本功能：</p><p>​    （1）防止硬件被失控的应用程序滥用</p><p>​    （2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</p><p>操作系统通过几个基本的抽象概念(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)来实现这两个功能.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-11.png" alt="操作系统提供的抽象表示"></p><p>文件是对I/O设备的抽象表示，虚拟内存是对贮存和磁盘I/O的抽象表示，进操则是对处理器、主存和I/O设备的抽象表示.</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件.而<strong>并发运行</strong>则说的是一个进程的指令和另一个进程的指令是交错执行的.在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的.传统系统在一个时刻只能执行一个程序，而现今的<strong>多核</strong>处理器同时能够执行多个程序，无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的，操作系统实现这种交错执行地机制称为<strong>上下文切换</strong>.</p><p>操作系统保持跟踪进程所需地所有状态信息，这种状态就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容.在任何一个时刻，单处理器系统都只能执行一个程序的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行<strong>上下文切换</strong>，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-12.png" alt="进程的上下文切换"></p><p>从一个进程到另一个进程的转换是由操作系统<strong>内核</strong>(kernel)管理的，内核是操作系统代码常驻主存的部分.当应用程序需要操作系统的某些操作时，它就执行一条特殊的<strong>系统调用</strong>(system call)指令，将控制权传递给内核，然后内核执行被请求的操作并返回应用程序.注意，内核不是一个独立的进程，相反，它是系统管理全部进程所用代码和数据结构的集合.实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作.</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据.</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><strong>虚拟内存</strong>是一个抽象的概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存，每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-13.png" alt="Linux进程的虚拟地址空间"></p><p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能.</p><ul><li>程序代码和数据    对所有进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置，代码和数据区是直接按照可执行目标文件的内容初始化的.</li><li>堆    代码和数据区后紧随着的是运行时<strong>堆</strong>，代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩.</li><li>共享库    大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码于数据的区域.</li><li>栈    位于用户虚拟地址空间顶部的是用户<strong>栈</strong>，编译器用它来实现函数调用，和堆一样，用户栈在程序执行期间可以动态地扩展和收缩.特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩.</li><li>内核虚拟内存    地址空间顶部的区域是为内核保留地，不允许应用程序读写这个区域地内容或者直接调用内核代码定义的函数，相反，它们必须调用内核来执行这些操作.</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>文件</strong>就是字节序列，每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件.文件的概念是非常强大的，它向应用程序提供了一个统一的视图，来看待系统中可能含有地所有各式各样的I/O设备.</p><h1 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h1><p>现代系统经常通过网络和其他系统连接到一起，从每个单独的系统来看，网络可视为一个I/O设备.</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F_1-14.png" alt="网络也是一种I/O设备"></p><p>当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存.</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序.计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式.程序被其他程序翻译成不同的形式，开始时时ASCII文本，然后被编译器和链接器翻译成二进制可执行文件.</p><p>处理器读取并解是存放在主存里的二进制指令.因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器制间复制数据，所以将系统中的存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器.在层次模型中，位于更高层的存储设备比底层的存储设备要更快，单位比特造假也更高.层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存.通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能.</p><p>操作系统内核时应用程序和硬件制间的媒介.它提供三个基本的抽象：1）文件是对I/O设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和I/O设备的抽象.</p><p>最后，网络提供了计算机系统之间通信的手段.从特殊系统的角度来看，网络就是一种I/O设备.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re_x64汇编基础</title>
      <link href="2021/03/25/Re_x64%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/25/Re_x64%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>x64汇编基础</strong></p><p>x86-64 (也被称为 x64 或者 AMD64) 是 64 位版本的 x86/IA32 指令集.</p><hr><hr><h1 id="寄存器-Registers"><a href="#寄存器-Registers" class="headerlink" title="寄存器 Registers"></a>寄存器 Registers</h1><hr><p>x86-64CPU中共有16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针.<br>64位CPU的前8个寄存器是从32位CPU中的%eax到%esp的8个寄存器，从32位扩展为64位，同时，名称也变为了从%rax到%rsp.另外的8个寄存器是新增的，标号从%r8到%r15.</p><table><thead><tr><th align="center"><strong>Register</strong></th><th align="center"><strong>标号</strong></th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center"><strong>RAX</strong></td><td align="center"><strong>%rax</strong></td><td align="center"><strong>返回值寄存器</strong></td></tr><tr><td align="center"><strong>RBX</strong></td><td align="center"><strong>%rbx</strong></td><td align="center"><strong>可用作帧指针；必须由被调用方保留</strong></td></tr><tr><td align="center"><strong>RCX</strong></td><td align="center"><strong>%rcx</strong></td><td align="center"><strong>第四个参数</strong></td></tr><tr><td align="center"><strong>RDX</strong></td><td align="center"><strong>%rdx</strong></td><td align="center"><strong>第三个参数</strong></td></tr><tr><td align="center"><strong>RSI</strong></td><td align="center"><strong>%rsi</strong></td><td align="center"><strong>第二个参数</strong></td></tr><tr><td align="center"><strong>RDI</strong></td><td align="center"><strong>%rdi</strong></td><td align="center"><strong>第一个参数</strong></td></tr><tr><td align="center"><strong>RBP</strong></td><td align="center"><strong>%rbp</strong></td><td align="center"><strong>可用作帧指针；必须由被调用方保留</strong></td></tr><tr><td align="center"><strong>RSP</strong></td><td align="center"><strong>%rsp</strong></td><td align="center"><strong>堆栈指针</strong></td></tr><tr><td align="center"><strong>R8</strong></td><td align="center"><strong>%r8</strong></td><td align="center"><strong>第五个参数</strong></td></tr><tr><td align="center"><strong>R9</strong></td><td align="center"><strong>%r9</strong></td><td align="center"><strong>第六个参数</strong></td></tr><tr><td align="center"><strong>R10</strong></td><td align="center"><strong>%r10</strong></td><td align="center"><strong>必须根据需要由调用方保留；在 syscall/sysret 指令中使用</strong></td></tr><tr><td align="center"><strong>R11</strong></td><td align="center"><strong>%r11</strong></td><td align="center"><strong>必须根据需要由调用方保留；在 syscall/sysret 指令中使用</strong></td></tr><tr><td align="center"><strong>R12</strong></td><td align="center"><strong>%r12</strong></td><td align="center"><strong>必须由被调用方保留</strong></td></tr><tr><td align="center"><strong>R13</strong></td><td align="center"><strong>%r13</strong></td><td align="center"><strong>必须由被调用方保留</strong></td></tr><tr><td align="center"><strong>R14</strong></td><td align="center"><strong>%r14</strong></td><td align="center"><strong>必须由被调用方保留</strong></td></tr><tr><td align="center"><strong>R15</strong></td><td align="center"><strong>%r15</strong></td><td align="center"><strong>必须由被调用方保留</strong></td></tr></tbody></table><p>每个寄存器都是 64 bit 宽, 它们的低 32, 16, 8 位都可以看成相应的 32, 16, 8 位寄存器, 并且都有其特殊名称. 一些寄存器被设计用来完成某些特殊目的, 比如 %rsp 被用来作为栈指针, %rax 作为一个函数的返回值. 其他寄存器则都是通用的, 但是一般在使用的时候, 还是要取决于调用者 ( Caller-owned )或者被调用者 ( Callee-owned ). 如果函数 binky 调用了 winky, 我们称 binky 为调用者, winky 为被调用者. </p><p>例如, 用于前 6 个参数和返回值的寄存器都是被调用者所有的 ( Callee-owned ). 被调用者可以任意使用这些寄存器, 不用任何预防措施就可以随意覆盖里面的内容. 如果 <code>%rax</code> 存着调用者想要保留的值, 则 Caller 必须在调用之前将这个 <code>%rax</code> 的值复制到一个 “ 安全 “ 的位置. 被调用者拥有的 ( Callee-owned ) 寄存器非常适合一些临时性的使用. 相反, 如果被调用者打算使用调用者所拥有的寄存器, 那么被调用者必须首先把这个寄存器的值存起来, 然后在退出调用之前把它恢复. 调用者拥有的 ( Caller-owned ) 寄存器用于保存调用者的本地状态 ( local state ), 所以这个寄存器需要在进一步的函数调用中被保留下来.</p><h1 id="寻址模式-Addressing-modes"><a href="#寻址模式-Addressing-modes" class="headerlink" title="寻址模式 Addressing modes"></a>寻址模式 Addressing modes</h1><hr><p>由于 CISC 特性, X86-64 支持各种寻址模式. 寻址模式是计算要读或写的内存地址的表达式. 这些表达式用作<code>mov</code>指令和访问内存的其它指令的来源和去路. 下面的代码演示了如何在每个可用的寻址模式中将 立即数 1 写入各种内存位置 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl $1, 0x604892         ;直接写入, 内存地址是一个常数</span><br><span class="line">movl $1, (%rax)           ;间接写入, 内存地址存在寄存器 %rax 中</span><br><span class="line"></span><br><span class="line">movl $1, -24(%rbp)       ;使用偏移量的间接写入</span><br><span class="line">                         ;公式 : (address &#x3D; base %rbp + displacement -24)</span><br><span class="line"></span><br><span class="line">movl $1, 8(%rsp, %rdi, 4) ;间接写入, 用到了偏移量和按比例放大的索引 ( scaled-index )</span><br><span class="line">           ;公式 : (address &#x3D; base %rsp + displ 8 + index %rdi * scale 4)</span><br><span class="line"></span><br><span class="line">movl $1, (%rax, %rcx, 8) ;特殊情况, 用到了按比例放大的索引 ( scaled-index ), 假设偏移量 ( displacement ) 为 0</span><br><span class="line"></span><br><span class="line">movl $1, 0x8(, %rdx, 4)  ;特殊情况, 用到了按比例放大的索引 ( scaled-index ), 假设基数 ( base ) 为 0</span><br><span class="line">movl $1, 0x4(%rax, %rcx) ;特殊情况, 用到了按比例放大的索引 ( scaled-index ), 假设比例 ( scale ) 为0</span><br></pre></td></tr></table></figure><h1 id="通用指令-Common-instructions"><a href="#通用指令-Common-instructions" class="headerlink" title="通用指令 Common instructions"></a>通用指令 Common instructions</h1><hr><p>指令后缀 : 许多指令都有个后缀 ( b, w, l, q ) , 后缀指明了这个指令代码所操纵参数数据的位宽 ( 分别为 1, 2, 4 或 8 个字节 ). 当然, 如果可以从参数确定位宽的时候, 后缀可以被省略. 例如, 如果目标寄存器是 %eax, 则它必须是 4 字节宽, 如果是 %ax 寄存器, 则必须是 2 个字节, 而 %al 将是 1 个字节. 还有些指令, 比如 <code>movs</code> 和 <code>movz</code> 有两个后缀 : 第一个是来源参数, 第二个是去路. 例如, <code>movzbl</code> 这个指令把 1 个字节的来源参数值移动到 4 个字节的去路.</p><p>当目标是子寄存器 ( sub-registers ) 时, 只有子寄存器的特定字节被写入, 但有一个例外 : 32 位指令将目标寄存器的高 32 位设置为 0.</p><h2 id="mov-和-lea-指令"><a href="#mov-和-lea-指令" class="headerlink" title="mov 和 lea 指令"></a><code>mov</code> 和 <code>lea</code> 指令</h2><p> <code>mov</code>是目前最频繁遇到的指令, 而它有很多变种. 关于 <code>mov</code> 指令就不多说了, 和之前 32 位 x86 的没什么区别. <code>lea</code> 指令其实也没什么好说的, <a href="https://aloof77.github.io/2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/#%E6%8C%87%E4%BB%A4-Instructions">上一节</a>都有, 这里就不废话了.</p><p>这里写几个比较有意思的例子 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 8(%rsp), %eax    ;%eax &#x3D; 从地址 %rsp + 8 读取的值</span><br><span class="line">lea 0x20(%rsp), %rdi ;%rdi &#x3D; %rsp + 0x20</span><br><span class="line">lea (%rdi,%rdx,1), %rax  ;%rax &#x3D; %rdi + %rdx</span><br></pre></td></tr></table></figure><p>在把较小位宽的数据移动复制到较大位宽的情况下, <code>movs</code> 和 <code>movz</code> 这两个变种指令用于指定怎么样去填充字节, 因为你是一个小东西被移到了一个大空间, 肯定还有地方是空的, 所以<strong>空的地方要填起来, 拿 0 或者 符号扩展 ( sign-extend ) 来填充.</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movsbl %al, %edx     ;把 1 个字节的 %al, 符号扩展 复制到 4 字节的 %edx</span><br><span class="line">movzbl %al, %edx     ;把 1 个字节的 %al, 零扩展 ( zero-extend ) 复制到 4 字节的 %edx</span><br></pre></td></tr></table></figure><p>有个特殊情况要注意, 默认情况下, 将 32 位值写入寄存器的 <code>mov</code> 指令, 也会将寄存器的高 32 位归零, 即隐式零扩展到位宽 q. 这个解释了诸如 <code>mov %ebx, %ebx</code> 这种指令, 这些指令看起来很奇怪, 但实际上这是用于从 32 位扩展到 64 位. 因为这个是默认的, 所以我们不用显式的 <code>movzlq</code> 指令. 当然, 有一个 <code>movslq</code> 指令也是从 32 位符号扩展到 64 位.</p><p><code>cltq</code> 指令是一个在 %rax 上运行的专用移动指令. 这个没有参数的指令在 %rax 上进行符号扩展, 源位宽为 L, 目标位宽为 q.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cltq   ;在 ％rax 上运行，将 4 字节 src 符号扩展为 8 字节 dst，用于 movslq ％eax，％rax</span><br></pre></td></tr></table></figure><h2 id="算术和位运算"><a href="#算术和位运算" class="headerlink" title="算术和位运算"></a>算术和位运算</h2><p>二进制的运算一般是两个参数, 其中第二个参数既是我们指令运算的来源, 也是去路的来源, 就是说我们<strong>把运算结果存在第二个参数里. 我们的第一个参数可以是立即数常数, 寄存器或者内存单元. 第二个参数必须是寄存器或者内存.</strong> 这两个参数中, 最多只有一个参数是内存单元, 当然也有的指令只有一个参数, 这个参数既是我们运算数据的来源, 也是我们运算数据的去路, 它可以是寄存器或者内存. 这个我们上一节讲了, 这里回顾一下. 许多算术指令用于有符号和无符号类型,也就是带符号加法和无符号加法都使用相同的指令. 当需要的时候, 参数设置的条件代码可以用来检测不同类型的溢出.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add src, dst ;dst &#x3D; dst + src</span><br><span class="line">sub src, dst ;dst &#x3D; dst - src</span><br><span class="line">imul src, dst ;dst &#x3D; dst * src</span><br><span class="line">neg dst ;dst &#x3D; -dst ( 算术取反 )</span><br><span class="line"></span><br><span class="line">and src, dst ;dst &#x3D; dst &amp; src</span><br><span class="line">or src, dst ;dst &#x3D; dst | src</span><br><span class="line">xor src, dst ;dst &#x3D; dst ^ src</span><br><span class="line">not dst ;dst &#x3D; ~dst ( 按位取反 )</span><br><span class="line"></span><br><span class="line">shl count, dst ;dst &lt;&lt;&#x3D; count ( 按 count 的值来左移 ), 跟这个相同的是&#96;sal&#96;指令</span><br><span class="line">sar count, dst ;dst &#x3D; count ( 按 count 的值来算术右移 )</span><br><span class="line">shr count, dst ;dst &#x3D; count ( 按 count 的值来逻辑右移 )</span><br><span class="line"></span><br><span class="line">;某些指令有特殊情况变体, 这些变体有不同的参数</span><br><span class="line">imul src ;一个参数的 imul 指令假定 %rax 中其他参数计算 128 位的结果, 在 %rdx 中存储高 64 位, 在 %rax 中存储低 64 位.</span><br><span class="line">shl dst ;dst &lt;&lt;&#x3D; 1 ( 后面没有 count 参数的时候默认是移动 1 位, &#96;sar&#96;, &#96;shr&#96;, &#96;sal&#96; 指令也是一样 )</span><br></pre></td></tr></table></figure><h2 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h2><p>有一个特殊的 %eflags 寄存器, 它存着一组被称为条件代码的布尔标志. 大多数的算术运算会更新这些条件代码. 条件跳转指令读取这些条件代码之后, 再确定是否执行相应的分支指令. <strong>条件代码包括 ZF( 零标志 ), SF( 符号标志 ), OF( 溢出标志, 有符号 ) 和 CF( 进位标志, 无符号 ).</strong> 例如, 如果结果为 0 , 则设置 ZF, 如果操作溢出 ( 进入符号位 ), 则设置 OF.</p><p>这些指令一般是先执行 <code>cmp</code> 或 <code>test</code> 操作来设置标志, 然后再跟跳转指令变量, 该变量读取标志来确定是采用分支代码还是继续下一条代码. <code>cmp</code> 或 <code>test</code> 的参数是立即数, 寄存器或者内存单元 ( 最多只有一个内存参数 ). 条件跳转有 32 中变体, 其中几种效果是一样的. 下面是一些分支指令.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmpl op2, op1 ;运算结果 &#x3D; op1 - op2, 丢弃结果然后设置条件代码</span><br><span class="line">test op2, op1 ;运算结果 &#x3D; op1 &amp; op2, 丢弃结果然后设置条件代码</span><br><span class="line"></span><br><span class="line">jmp target ;无条件跳跃</span><br><span class="line">je target ;等于时跳跃, 和它相同的还有 jz, 即jump zero ( ZF &#x3D; 1 )</span><br><span class="line">jne target ;不相等时跳跃, 和它相同的还有 jnz, 即 jump non zero ( ZF &#x3D; 0 )</span><br><span class="line">jl target ;小于时跳跃, 和它相同的还有 jnge, 即 jump not greater or equal ( SF !&#x3D; OF )  </span><br><span class="line">jle target ;小于等于时跳跃, 和它相同的还有 jng, 即 jump not greater ( ZF &#x3D; 1 or SF !&#x3D; OF )</span><br><span class="line">jg target ;大于时跳跃, 和它相同的还有 jnle, 即 jump not less or equal ( ZF &#x3D; 0 and SF &#x3D; OF )</span><br><span class="line">jge target ;大于等于时跳跃, 和它相同的还有 jnl, 即 jump not less ( SF &#x3D; OF )</span><br><span class="line">ja  target ;跳到上面, 和它相同的还有 jnbe, 即 jump not below or equal ( CF &#x3D; 0 and ZF &#x3D; 0 )</span><br><span class="line">jb  target ;跳到下面, 和它相同的还有 jnae, 即 jump not above or equal ( CF &#x3D; 1 )</span><br><span class="line">js  target ;SF &#x3D; 1 时跳跃</span><br><span class="line">jns target ;SF &#x3D; 0 时跳跃</span><br></pre></td></tr></table></figure><h2 id="setx和movx"><a href="#setx和movx" class="headerlink" title="setx和movx"></a><code>setx</code>和<code>movx</code></h2><p>还有两个指令家族可以 读取/响应 当前的条件代码. <code>setx</code> 指令根据条件 x 的状态将目标寄存器设置为 0 或 1. <code>cmovx</code> 指令根据条件 x 是否成立来有条件地执行 mov. x 是任何条件变量的占位符, 就是说 x 可以用这些来代替 : e, ne, s, ns. 它们的意思上面也都说过了.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sete dst ;根据 零&#x2F;相等( zero&#x2F;equal ) 条件来把 dst 设置成 0 或 1</span><br><span class="line">setge dst ;根据 大于&#x2F;相等( greater&#x2F;equal ) 条件来把 dst 设置成 0 或 1</span><br><span class="line">cmovns src, dst ;如果 ns 条件成立, 则继续执行 mov</span><br><span class="line">cmovle src, dst ;如果 le 条件成立, 则继续执行 mov</span><br></pre></td></tr></table></figure><p><strong>对于 <code>setx</code> 指令, 其目标必须是单字节寄存器 ( 例如 %al 用于 %rax 的低字节 ). 对于 <code>cmovx</code> 指令, 其来源和去路都必须是寄存器.</strong></p><h2 id="函数调用与栈"><a href="#函数调用与栈" class="headerlink" title="函数调用与栈"></a>函数调用与栈</h2><p>%rsp 寄存器用作 “ 栈指针 “; <code>push</code> 和 <code>pop</code> 用于添加或者删除栈内存中的值. <code>push</code> 指令只有一个参数, 这个参数是立即数常数, 寄存器或内存单元. <code>push</code> 指令先把 %rsp 的值递减, 然后将参数复制到栈内存上的 tompost. <code>pop</code> 指令也只有一个参数, 即目标寄存器. <code>pop</code> 先把栈内存最顶层的值复制到目标寄存器, 然后把 %rsp 递增. 直接调整 %rsp, 以通过单个参数添加或删除整个数组或变量集合也是可以的. 但注意, 栈内存是朝下增长 ( 即朝向较低地址 ).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %rbx ;把 %rbx 入栈</span><br><span class="line">pushq $0x3 ;把立即数 3 入栈</span><br><span class="line">sub $0x10, %rsp ;调整栈指针以空出 16 字节</span><br><span class="line"></span><br><span class="line">pop %rax ;把栈中最顶层的值出栈到寄存器 %rax 中</span><br><span class="line">add $0x10, %rsp ;调整栈指针以删除最顶层的 16 个字节</span><br></pre></td></tr></table></figure><p>函数之间是通过互相调用返回来互相控制的. <code>callq</code> 指令有一个参数, 即被调用的函数的地址. 它将返回来的地址入栈, 这个返回来的地址即 %rip 当前的值, 也即是调用函数后的下一条指令. 然后这个指令让程序跳转到被调用的函数的地址. <code>retq</code> 指令把刚才入栈的地址给出栈, 让它回到 %rip 中, 从而让程序在保存的返回地址处重新开始, 就是说你中途跳到别的地方去, 你回来的时候要从你跳的那个地方重新开始.</p><p>当然, 你如果要设置这种函数间的互相调用, 调用者需要将前六个参数放入寄存器 %rdi, %rsi, %rdx, %rcx, %r8 和 %r9 ( 任何其它参数都入栈 ), 然后再执行调用指令.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x3, %rdi ;第一个参数在 %rdi 中</span><br><span class="line">mov $0x7, %rsi ;第二个参数在 %rsi 中</span><br><span class="line">callq binky ;把程序交给 binky 控制</span><br></pre></td></tr></table></figure><p>当被调用者那个函数完事的时候, 这个函数将返回值 ( 如果有的话 ) 写入 %rax, 然后清理栈内存, 并使用 <code>retq</code> 指令把程序控制权交还给调用者.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x0, %eax ;将返回值写入 %rax</span><br><span class="line">add $0x10, %rsp ;清理栈内存</span><br><span class="line">retq ;交还控制权, 跳回去</span><br></pre></td></tr></table></figure><p>这些分支跳转指令的目标通常是在编译时确定的绝对地址. 但是, 有些情况下直到运行程序的时候, 我们才知道目标的绝对内存地址. 例如编译为跳转表的 switch 语句或调用函数指针时. 对于这些, 我们先计算目标地址, 然后把地址存到寄存器中, 然后用 分支/调用( branch/call ) 变量 <code>je *%rax</code> 或 <code>callq *%rax</code> 从指定寄存器中读取目标地址.</p><p>当然还有更简单的方法, 就是上一节讲的打标签.</p><h1 id="汇编和-gdb"><a href="#汇编和-gdb" class="headerlink" title="汇编和 gdb"></a>汇编和 gdb</h1><p>调试器 ( debugger ) 有许多功能, 这可以让你可以在程序中追踪和调试代码. 你可以<strong>通过在其名称上加个 $ 来打印寄存器中的值, 或者使用命令 info reg 转储所有寄存器的值 :</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p $rsp</span><br><span class="line">(gdb) info reg</span><br></pre></td></tr></table></figure><p><code>disassemble</code> 命令按照名称打印函数的反汇编. <code>x</code> 命令支持 i 格式, 这个格式把内存地址的内容解释为编码指令 ( 解码 ).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main &#x2F;&#x2F;反汇编, 然后打印所有 main 函数的指令</span><br><span class="line">(gdb) x&#x2F;8i main &#x2F;&#x2F;反汇编, 然后打印开始的 8 条指令</span><br></pre></td></tr></table></figure><p>你可以<strong>通过在函数中的直接地址或偏移量为特定汇编指令设置断点.</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b *0x08048375</span><br><span class="line">(gdb) b *main+7 &#x2F;&#x2F;在 main+7个字节这里设置断点</span><br></pre></td></tr></table></figure><p>你可以用 <code>stepi</code> 和 <code>nexti</code> 命令来让程序通过指令 ( 而不是源代码 ) 往前执行.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) stepi</span><br><span class="line">(gdb) nexti</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
          <category> 汇编 </category>
          
          <category> x64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> 汇编 </tag>
            
            <tag> x64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse</title>
      <link href="2021/03/25/Reverse/"/>
      <url>2021/03/25/Reverse/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re_常用操作</title>
      <link href="2021/03/20/Re_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2021/03/20/Re_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="upx脱壳-kali"><a href="#upx脱壳-kali" class="headerlink" title="upx脱壳 kali"></a>upx脱壳 kali</h4><p><code>upx -d filename</code></p><h4 id="IDApython"><a href="#IDApython" class="headerlink" title="IDApython"></a>IDApython</h4><p><a href="https://blog.csdn.net/qq_43557177/article/details/104776848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161689715716780274172467%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161689715716780274172467&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-104776848.first_rank_v2_pc_rank_v29&utm_term=ida+python+patchbyte">用法</a></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
          <category> 常用操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> 常用操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re_x86汇编基础</title>
      <link href="2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/18/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>X86 汇编基础</strong></p><hr><hr><h1 id="寄存器-Registers"><a href="#寄存器-Registers" class="headerlink" title="寄存器 Registers"></a>寄存器 Registers</h1><hr><p>现代 ( 386及以上的机器 )x86 处理器有 8 个 32 位通用寄存器.</p><p><img src="/images/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80_x86-registers.png" alt="x86-registers"></p><p>这些寄存器的名字都是有点历史的, 例如 <code>EAX</code> 过去被称为 <em>累加器</em>, 因为它被用来作很多算术运算, 还有 <code>ECX</code> 被称为 <em>计数器</em> , 因为它被用来保存循环的索引 ( 就是循环次数 ). 尽管大多是寄存器在现代指令集中已经失去了它们的特殊用途, 但是按照惯例, 其中有两个寄存器还是有它们的特殊用途 —<code>ESP</code> 和 <code>EBP</code> .</p><p><a href="https://blog.csdn.net/freeking101/article/details/99093930">寄存器</a>就好比是 CPU 身上的口袋，方便 CPU 随时从里面拿出需要的东西来使用.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EBA: 扩展基址寄存器</span><br><span class="line">ECX: 扩展计数寄存器</span><br><span class="line">EDX: 扩展数据寄存器</span><br><span class="line">ESI: 扩展来源寄存器</span><br><span class="line">EDI: 扩展目标寄存器</span><br><span class="line"></span><br><span class="line">EBP：扩展基址指针寄存器</span><br><span class="line">ESP：扩展堆栈指针寄存器.栈顶指针，指向当前堆栈的栈底</span><br><span class="line">EIP：扩展指令指针寄存器</span><br></pre></td></tr></table></figure><p><img src="/images/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80_stack.jpg" alt="stack"></p><p>对于 <code>EAS</code>, <code>EBX</code>, <code>ECX</code> 还有 <code>EDX</code> 寄存器, 它们可以被分段开来使用. 例如, 可以将 <code>EAX</code> 的最低的 2 位字节视为 16 位寄存器  <code>AX</code> . 还可以将 <code>AX</code> 的最低位的 1 个字节看成 8 位寄存器来用  <code>AL</code>, 当然 <code>AX</code> 的高位的 1 个字节也可以看成是一个 8 位寄存器  <code>AH</code> . 这些名称有它们相对应的物理寄存器. 当两个字节大小的数据被放到 <code>DX</code> 的时候, 原本 <code>DH</code>, <code>DL</code> 和 <code>EDX</code> 的数据会受到影响 ( 被覆盖之类的 ). 这些 “ 子寄存器 “ 主要来自于比较久远的 16 位版本指令集. 然而, 在处理小于 32 位的数据的时候, 比如 1 个字节的 ASCII 字符, 它们有时会很方便stack.</p><h1 id="内存和寻址模式-Memory-and-Addressing-Modes"><a href="#内存和寻址模式-Memory-and-Addressing-Modes" class="headerlink" title="内存和寻址模式 Memory and Addressing Modes"></a>内存和寻址模式 Memory and Addressing Modes</h1><hr><h2 id="声明静态数据区域"><a href="#声明静态数据区域" class="headerlink" title="声明静态数据区域"></a>声明静态数据区域</h2><p>可以用特殊的x86汇编指令在内存中声明静态数据区域(类似于全局变量). <code>.data</code>指令用来声明数据，**<code>根据这条指令，.byte，.short 和.long可以分别用来声明1个字节，2个字节和4个字节的数据.</code><strong>我们可以给它们打个标签, 用来引用创建的数据的地址. <em><em>标签在汇编语言中是非常有用的, 它们给内存地址命名, 然后</em>编译器* 和*链接器</em> 将其 “ 翻译 “ 成计算机理解的机器代码.</strong> 这个跟用名称来声明变量很类似, 但是它遵守一些较低级别的规则. 例如, 按顺序声明的位置将彼此相邻地存储在内存中. 这话也许有点绕, 就是按照顺序打的标签, 这些标签对应的数据也会按照顺序被放到内存中.例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var :</span><br><span class="line">       .byte 64 ;&#x2F;&#x2F;声明一个字节型变量 var, 其所对应的数据是64</span><br><span class="line">       .byte 10 ;&#x2F;&#x2F;声明一个数据 10, 这个数据没有所谓的 &quot; 标签 &quot;, 它的内存地址就是 var+1.</span><br><span class="line"></span><br><span class="line">x :</span><br><span class="line">       .short 42 ;&#x2F;&#x2F;声明一个大小为 2 个字节的数据, 这个数据有个标签 &quot; x &quot;</span><br><span class="line"></span><br><span class="line">y :</span><br><span class="line">       .long 30000 ;&#x2F;&#x2F;声明一个大小为 4 个字节的数据, 这个数据标签是 &quot; y &quot;,  y 的值被初始化为 30000</span><br></pre></td></tr></table></figure><p>与高级语言不同, 高级语言的数组可以具有多个维度并且可以通过索引来访问, x86 汇编语言的数组只是在内存中连续的” 单元格 “. <strong>只需要把数值列出来就可以声明一个数组</strong>, 比如下面的第一个例子. 对于一些字节型数组的特殊情况, 我们可以使用字符串. 如果要在大多数的内存填充 0, 你可以使用<code>.zero</code>指令.例子 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s :</span><br><span class="line">       .long 1, 2, 3 ;&#x2F;&#x2F;声明 3 个大小为 4 字节的数据 1, 2, 3. 内存中 s+8 这个标签所对应的数据就是 3.</span><br><span class="line"></span><br><span class="line">barr:</span><br><span class="line">       .zero 10 ;&#x2F;&#x2F;从 barr 这个标签的位置开始, 声明 10 个字节的数据, 这些数据被初始化为 0.</span><br><span class="line"></span><br><span class="line">str :</span><br><span class="line">       .string &quot;hello&quot; ;&#x2F;&#x2F;从 str 这个标签的位置开始, 声明 6 个字节的数据, 即 hello 对应的 ASCII 值, 这最后还跟有一个 nul(0) 字节.</span><br></pre></td></tr></table></figure><h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><p>现代x86兼容处理器能够寻址高达 2^32 字节的内存 : 内存地址为 32 位宽. 在上面的示例中，我们使用标签来引用内存区域，这些标签实际上被 32 位数据的汇编程序替换，这些数据指定了内存中的地址. 除了支持通过标签（即常数值）引用存储区域之外，x86提供了一种灵活的计算和引用内存地址的方案 ：最多可将两个32位寄存器和一个32位有符号常量相加，以计算存储器地址. 其中一个寄存器可以选择预先乘以 2, 4 或 8.</p><p>寻址模式可以和许多 x86 指令一起使用. 这里用<code>mov</code>指令在寄存器和内存中移动数据当作例子. *这个指令有两个参数, 第一个是数据的来源, 第二个是数据的去向.*一些<code>mov</code>的例子 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov (%ebx), %eax ;&#x2F;&#x2F;从 EBX 中的内存地址加载 4 个字节的数据到 EAX, 就是把 EBX 中的内容当作标签, 这个标签在内存中对应的数据放到 EAX 中;后面如果没有说明的话, (%ebx)就表示寄存器ebx中存储的内容</span><br><span class="line"></span><br><span class="line">mov %ebx, var(,1) ; &#x2F;&#x2F;将 EBX 中的 4 个字节大小的数据移动的内存中标签为 var 的地方去.( var 是一个 32 位常数).</span><br><span class="line"></span><br><span class="line">mov (%esi, %ebx, 4), %edx ;&#x2F;&#x2F;将内存中标签为 ESI+4*EBX 所对应的 4 个字节大小的数据移动到 EDX中.</span><br></pre></td></tr></table></figure><p>一些<strong>错误</strong>的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov (%ebx, %ecx, -1), %eax ;&#x2F;&#x2F;这个只能把寄存器中的值加上一遍.</span><br><span class="line">mov %ebx,(%eax, %esi, %edi, 1) ;&#x2F;&#x2F;在地址计算中, 最多只能出现 2 个寄存器, 这里却有 3 个寄存器.</span><br></pre></td></tr></table></figure><h2 id="操作后缀"><a href="#操作后缀" class="headerlink" title="操作后缀"></a>操作后缀</h2><p>通常, 给定内存地址的数据类型可以从引用它的汇编指令推断出来. 例如, 在上面的指令中, 你可以从寄存器操作数的大小来推出其所占的内存大小. 当我们加载一个 32 位的寄存器的时候, 编译器就可以推断出我们用到的内存大小是 4 个字节宽. 当我们将 1 个字节宽的寄存器的值保存到内存中时, 编译器可以推断出我们想要在内存中弄个 1 字节大小的 “ 坑 “ 来保存我们的数据.</p><p>然而在某些情况下, 我们用到的内存中 “ 坑 “ 的大小是不明确的. 比如说这条指令 <code>mov $2,(%ebx)</code>. 这条指令是否应该将 “ 2 “ 这个值移动到 EBX 中的值所代表的地址 “ 坑 “ 的单个字节中 ? 也许它表示的是将 32 位整数表示的 2 移动到从地址 EBX 开始的 4 字节. 既然这两个解释都有道理, 但计算机汇编程序必须明确哪个解释才是正确的, 计算机很单纯的, 要么是错的要么是对的. 前缀 b, w, 和 l 就是来解决这个问题的, 它们分别表示 1, 2 和 4 个字节的大小.例子 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movb $2, (%ebx) ;&#x2F;&#x2F;将 2 移入到 ebx 中的值所表示的地址单元中.</span><br><span class="line">movw $2, (%ebx) ;&#x2F;&#x2F;将 16 位整数 2 移动到 从 ebx 中的值所表示的地址单元 开始的 2 个字节中.</span><br><span class="line">movl $2,(%ebx) ;&#x2F;&#x2F;将 32 位整数 2 移动到 从 ebx中的值表示的地址单元 开始的 4 个字节中.</span><br></pre></td></tr></table></figure><h1 id="指令-Instructions"><a href="#指令-Instructions" class="headerlink" title="指令 Instructions"></a>指令 Instructions</h1><hr><p>机器指令通常分为 3 类 : 数据移动指令, 逻辑运算指令和流程控制指令. 完整的指令列表, 请参阅 <a href="https://max.book118.com/html/2016/0414/40417180.shtm">intel 的指令集参考手册</a>.</p><p>下面将使用以下符号 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;reg32 任意的 32 位寄存器 (%eax, %ebx, %ecx, %edx, %esi, %edi, %esp 或者 %eb)</span><br><span class="line">&lt;reg16 任意的 16 位寄存器 (%ax, %bx, %cx 或者 %dx)</span><br><span class="line">&lt;reg8 任意的 8 位寄存器 (%ah, %al, %bh, %bl, %ch, %cl, %dh, %dl)</span><br><span class="line">&lt;reg 任意的寄存器</span><br><span class="line">&lt;mem 一个内存地址, 例如 (%eax), 4+var, (%eax, %ebx, 1)</span><br><span class="line">&lt;con32 32 位常数</span><br><span class="line">&lt;con16 16 位常数</span><br><span class="line">&lt;con8 8 位常数</span><br><span class="line">&lt;con 任意 32位, 16 位或者 8 位常数</span><br></pre></td></tr></table></figure><p>在汇编语言中, 用作<em>立即操作数</em> 的所有标签和数字常量 ( 即不在诸如<code>3 (%eax, %ebx, 8)</code>这样的地址计算中 ) 总是以美元符号 $ 为前缀. 需要的时候, 前缀 0x 表示十六进制数, 例如<code>$ 0xABC</code>. 如果没有前缀, 则默认该数字为十进制数.</p><h2 id="数据移动指令"><a href="#数据移动指令" class="headerlink" title="数据移动指令"></a>数据移动指令</h2><h3 id="mov-移动"><a href="#mov-移动" class="headerlink" title="mov 移动"></a><code>mov</code> 移动</h3><p><code>mov</code> 指令将数据从它的第一个参数 ( 即寄存器中的内容, 内存单元中的内容, 或者一个常数值 ) 复制到它的第二个参数 ( 即寄存器或者内存单元 ). 当寄存器到寄存器之间的数据移动是可行的时候, 直接地从内存单元中将数据移动到另一内存单元中是不行的. 在这种需要在内存单元中传递数据的情况下, 它数据来源的那个内存单元必须首先把那个内存单元中的数据加载到一个寄存器中, 然后才可以通过这个寄存器来把数据移动到目标内存单元中.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov &lt;reg, &lt;reg</span><br><span class="line">mov &lt;reg, &lt;mem</span><br><span class="line">mov &lt;mem, &lt;reg</span><br><span class="line">mov &lt;con, &lt;reg</span><br><span class="line">mov &lt;con, &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov %ebx, %eax ;&#x2F;&#x2F;将 EBX 中的值复制到 EAX 中</span><br><span class="line">mov $5, var(,1) ;&#x2F;&#x2F;将数字 5 存到字节型内存单元 &quot; var &quot;</span><br></pre></td></tr></table></figure><h3 id="push-入栈"><a href="#push-入栈" class="headerlink" title="push 入栈"></a><code>push</code> 入栈</h3><p><code>push</code>指令将它的参数移动到硬件支持的<strong>栈</strong>内存顶端. 特别地, <strong><code>push</code> 首先将 ESP 中的值减少 4,</strong> 然后将它的参数移动到一个 32 位的地址单元 ( %esp ). ESP ( 栈指针 ) 会随着不断入栈从而持续递减, 即<em><strong>栈内存是从高地址单元到低地址单元增长.</strong></em></p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push &lt;reg32</span><br><span class="line">push &lt;mem</span><br><span class="line">push &lt;con32</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %eax ;&#x2F;&#x2F;将 EAX 送入栈</span><br><span class="line">push var(,1) ;&#x2F;&#x2F;将 var 对应的 4 字节大小的数据送入栈中</span><br></pre></td></tr></table></figure><h3 id="pop-出栈"><a href="#pop-出栈" class="headerlink" title="pop 出栈"></a><code>pop</code> 出栈</h3><p><code>pop</code>指令从硬件支持的栈内存顶端移除 4 字节的数据, 并把这个数据放到该指令指定的参数中 ( 即寄存器或者内存单元 ). 其首先将内存中 ( %esp ) 的 4 字节数据放到指定的寄存器或者内存单元中, <strong>然后让 ESP + 4.</strong></p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop &lt;reg32</span><br><span class="line">pop &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop %edi ;&#x2F;&#x2F;将栈顶的元素移除, 并放入到寄存器 EDI 中.</span><br><span class="line">pop (%ebx) ;&#x2F;&#x2F;将栈顶的元素移除, 并放入从 EBX 开始的 4 个字节大小的内存单元中.</span><br></pre></td></tr></table></figure><p><strong>重点内容 : 栈 栈是一种特殊的存储空间, 特殊在它的访问形式上, 它的访问形式就是最后进入这个空间的数据, 最先出去, 也就是 “先进后出, 后进先出”.</strong></p><h3 id="lea加载有效地址"><a href="#lea加载有效地址" class="headerlink" title="lea加载有效地址"></a><code>lea</code>加载有效地址</h3><p><code>lea</code>指令将其第一个参数指定的<strong>内存单元</strong> 放入到 第二个参数指定的寄存器中. 注意, 该指令不加载内存单元中的内容, 只是计算有效地址并将其放入寄存器. 这对于获得指向存储器区域的指针或者执行简单的算术运算非常有用.</p><p>也许这里你会看得一头雾水, 不过你不必担心, 这里有更为通俗易懂的解释. <a href="https://zhidao.baidu.com/question/427095565.html"><strong>汇编语言中 lea 指令和 mov 指令的区别 ?</strong></a> <strong><code>MOV</code> 指令的功能是传送数据</strong>，例如 <code>MOV AX,[1000H]</code>，作用是将 1000H 作为偏移地址，寻址找到内存单元，将该内存单元中的数据送至 AX； <strong><code>LEA</code> 指令的功能是取偏移地址</strong>，例如 <code>LEA AX,[1000H]</code>，作用是将源操作数 [1000H] 的偏移地址 1000H 送至 AX.理解时，可直接将[ ]去掉，等同于 <code>MOV AX,1000H</code>. 再如：<code>LEA BX,[AX]</code>，等同于 <code>MOV BX,AX</code>；<code>LEA BX,TABLE</code> 等同于 <code>MOV BX,OFFSET TABLE</code>. 但有时不能直接使用 <code>MOV</code> 代替： 比如：<code>LEA AX,[SI+6]</code> 不能直接替换成：<code>MOV AX,SI+6</code>；但可替换为： <code>MOV AX,SI</code> <code>ADD AX,6</code> 两步完成.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea &lt;mem, &lt;reg32</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea (%ebx,%esi,8), %edi ;&#x2F;&#x2F;EBX+8*ESI 的值被移入到了 EDI</span><br><span class="line">lea val(,1), %eax ;&#x2F;&#x2F;val 的值被移入到了 EAX</span><br></pre></td></tr></table></figure><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><h3 id="add-整数相加"><a href="#add-整数相加" class="headerlink" title="add 整数相加"></a><code>add</code> 整数相加</h3><p><code>add</code> 指令将两个参数相加, 然后将结果存放到第二个参数中. 注意, <strong>参数可以是寄存器,但参数中最多只有一个内存单元.</strong> 这话有点绕, 我们直接看语法 :</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add &lt;reg, &lt;reg</span><br><span class="line">add &lt;mem, &lt;reg</span><br><span class="line">add &lt;reg, &lt;mem</span><br><span class="line">add &lt;con, &lt;reg</span><br><span class="line">add &lt;con, &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add $10, %eax ;&#x2F;&#x2F;EAX 中的值被设置为了 EAX+10.</span><br><span class="line">addb $10, (%eax) ;&#x2F;&#x2F;往 EAX 中的值 所代表的内存单元地址 加上 1 个字节的数字 10.</span><br></pre></td></tr></table></figure><h3 id="sub-整数相减"><a href="#sub-整数相减" class="headerlink" title="sub 整数相减"></a><code>sub</code> 整数相减</h3><p><code>sub</code>指令<strong>将第二个参数的值与第一个相减, 就是后面那个减去前面那个, 然后把结果存储到第二个参数</strong>. 和<code>add</code>一样, 两个参数都可以是寄存器, 但两个参数中最多只能有一个是内存单元.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub &lt;reg, &lt;reg</span><br><span class="line">sub &lt;mem, &lt;reg</span><br><span class="line">sub &lt;con, &lt;reg</span><br><span class="line">sub &lt;con, &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub %ah, %al ;&#x2F;&#x2F;AL 被设置成 AL-AH</span><br><span class="line">sub $216, %eax ;&#x2F;&#x2F;将 EAX 中的值减去 216</span><br></pre></td></tr></table></figure><h3 id="inc-dec-自增-自减"><a href="#inc-dec-自增-自减" class="headerlink" title="inc, dec 自增, 自减"></a><code>inc, dec</code> 自增, 自减</h3><p><code>inc</code> 指令让它的参数加 1, <code>dec</code> 指令则是让它的参数减去 1.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inc &lt;reg</span><br><span class="line">inc &lt;mem</span><br><span class="line">dec &lt;reg</span><br><span class="line">dec &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dec %eax ;&#x2F;&#x2F;EAX 中的值减去 1</span><br><span class="line">incl var(,1) ;&#x2F;&#x2F;将 var 所代表的 32 位整数加上 1.</span><br></pre></td></tr></table></figure><h3 id="imul-整数相乘"><a href="#imul-整数相乘" class="headerlink" title="imul 整数相乘"></a><code>imul</code> 整数相乘</h3><p><code>imul</code> 指令有两种基本格式 : 第一种是 2 个参数的 ( 看下面语法开始两条 ); 第二种格式是 3 个参数的 ( 看下面语法最后两条 ).</p><p>2 个参数的这种格式, <strong>先是将两个参数相乘, 然后把结果存到第二个参数中. 运算结果 ( 即第二个参数 ) 必须是一个寄存器.</strong></p><p>3 个参数的这种格式, <strong>先是将它的第 1 个参数和第 2 个参数相乘, 然后把结果存到第 3 个参数中, 当然, 第 3 个参数必须是一个寄存器. 此外, 第 1 个参数必须是一个常数.</strong></p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imul &lt;reg32, &lt;reg32</span><br><span class="line">imul &lt;mem, &lt;reg32</span><br><span class="line">imul &lt;con, &lt;reg32, &lt;reg32</span><br><span class="line">imul &lt;con, &lt;mem, &lt;reg32</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imul (%ebx), %eax ;&#x2F;&#x2F;将 EAX 中的 32 位整数, 与 EBX 中的内容所指的内存单元, 相乘, 然后把结果存到 EAX 中.</span><br><span class="line">imul $25, %edi, %esi ;&#x2F;&#x2F;ESI 被设置为 EDI * 25.</span><br></pre></td></tr></table></figure><h3 id="idiv-整数相除"><a href="#idiv-整数相除" class="headerlink" title="idiv 整数相除"></a><code>idiv</code> 整数相除</h3><p><strong><code>idiv</code>只有一个操作数，此操作数为除数，而被除数则为 EDX : EAX 中的内容（一个64位的整数）， 除法结果 ( 商 ) 存在 EAX 中, 而所得的余数存在 EDX 中.</strong></p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idiv &lt;reg32</span><br><span class="line">idiv &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idiv %ebx ;&#x2F;&#x2F;用 EDX : EAX 的值除以 EBX 的值. 商存放在 EAX 中, 余数存放在 EDX 中.</span><br><span class="line">idivw (%ebx) ;&#x2F;&#x2F;将 EDX : EAX 的值除以存储在 EBX 所对应内存单元的 32 位值. 商存放在 EAX 中, 余数存放在 EDX 中.</span><br></pre></td></tr></table></figure><h3 id="and-or-xor-按位逻辑-与-或-异或-运算"><a href="#and-or-xor-按位逻辑-与-或-异或-运算" class="headerlink" title="and, or, xor 按位逻辑 与, 或, 异或 运算"></a><code>and, or, xor</code> 按位逻辑 与, 或, 异或 运算</h3><p>这些指令分别对它们的参数进行相应的逻辑运算, <strong>运算结果存到第一个参数中.</strong></p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and &lt;reg, &lt;reg</span><br><span class="line">and &lt;mem, &lt;reg</span><br><span class="line">and &lt;reg, &lt;mem</span><br><span class="line">and &lt;con, &lt;reg</span><br><span class="line">and &lt;con, &lt;mem</span><br><span class="line"></span><br><span class="line">or &lt;reg, &lt;reg</span><br><span class="line">or &lt;mem, &lt;reg</span><br><span class="line">or &lt;reg, &lt;mem</span><br><span class="line">or &lt;con, &lt;reg</span><br><span class="line">or &lt;con, &lt;mem</span><br><span class="line"></span><br><span class="line">xor &lt;reg, &lt;reg</span><br><span class="line">xor &lt;mem, &lt;reg</span><br><span class="line">xor &lt;reg, &lt;mem</span><br><span class="line">xor &lt;con, &lt;reg</span><br><span class="line">xor &lt;con, &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and $0x0F, %eax ;&#x2F;&#x2F;只留下 EAX 中最后 4 位数字 (二进制位)</span><br><span class="line">xor %edx, %edx ;&#x2F;&#x2F;将 EDX 的值全部设置成 0</span><br></pre></td></tr></table></figure><h3 id="not-逻辑位运算-非"><a href="#not-逻辑位运算-非" class="headerlink" title="not 逻辑位运算 非"></a><code>not</code> 逻辑位运算 非</h3><p>对参数进行逻辑非运算, 即<strong>翻转参数中所有位的值</strong>.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">not &lt;reg</span><br><span class="line">not &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">not %eax ;&#x2F;&#x2F;将 EAX 的所有值翻转.</span><br></pre></td></tr></table></figure><h3 id="neg-取负指令"><a href="#neg-取负指令" class="headerlink" title="neg 取负指令"></a><code>neg</code> 取负指令</h3><p>取参数的二进制补码负数. 直接看例子也许会更好懂.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neg &lt;reg</span><br><span class="line">neg &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neg %eax ;&#x2F;&#x2F;EAX → -EAX</span><br></pre></td></tr></table></figure><h3 id="shl-shr-按位左移或者右移"><a href="#shl-shr-按位左移或者右移" class="headerlink" title="shl, shr 按位左移或者右移"></a><code>shl, shr</code> 按位左移或者右移</h3><p>这两个指令对第一个参数进行位运算, 移动的位数由第二个参数决定, <strong>移动过后的空位拿 0 补上</strong>.被移的参数最多可以被移 31 位. <strong>第二个参数可以是 8 位常数或者寄存器 CL. 在任意情况下, 大于 31 的移位都默认是与 32 取模</strong>.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shl &lt;con8, &lt;reg</span><br><span class="line">shl &lt;con8, &lt;mem</span><br><span class="line">shl %cl, &lt;reg</span><br><span class="line">shl %cl, &lt;mem</span><br><span class="line"></span><br><span class="line">shr &lt;con8, &lt;reg</span><br><span class="line">shr &lt;con8, &lt;mem</span><br><span class="line">shr %cl, &lt;reg</span><br><span class="line">shr %cl, &lt;mem</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shl $1, %eax ;&#x2F;&#x2F;将 EAX 的值乘以 2 (如果最高有效位是 0 的话)</span><br><span class="line">shr %cl, %ebx ;&#x2F;&#x2F;将 EBX 的值除以 2n, 其中 n 为 CL 中的值, 运算最终结果存到 EBX 中.</span><br></pre></td></tr></table></figure><h2 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h2><p>x86 处理器有一个<strong>指令指针寄存器 ( EIP )</strong>, 该寄存器为 32 位寄存器, 它用来在内存中指示我们<strong>输入汇编指令的位置.</strong> 就是说这个寄存器指向哪个内存单元, 那个单元存储的机器码就是程序执行的指令. 通常它是指向我们程序要执行的 下一条指令. <em>但是不能直接操作 EIP 寄存器, 你需要流程控制指令来隐式地给它赋值</em>.</p><p>我们**使用符号 <code>&lt;label</code> 来当作程序中的标签. 通过输入标签名称后跟冒号, 可以将标签插入 x86 汇编代码文本中的任何位置. **例如 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       mov 8(%ebp), %esi</span><br><span class="line">begin:</span><br><span class="line">       xor %ecx, %ecx</span><br><span class="line">       mov (%esi), %eax</span><br></pre></td></tr></table></figure><p>该代码片段中的第二段被套上了 “ begin “ 这个标签. <em>在代码的其它地方, 我们可以用 “ begin “ 这个标签从而更方便地来引用这段指令在内存中的位置. 这个标签只是用来更方便地表示位置的, 它并不是用来代表某个 32 位值.</em></p><h3 id="jmp-跳转指令"><a href="#jmp-跳转指令" class="headerlink" title="jmp 跳转指令"></a><code>jmp</code> 跳转指令</h3><p>将程序跳转到参数指定的内存地址, <strong>然后执行该内存地址的指令</strong>.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp &lt;label</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp begin ;&#x2F;&#x2F;跳转到打了 &quot; begin &quot; 这个标签的地方</span><br></pre></td></tr></table></figure><h3 id="jcondition-有条件的跳转"><a href="#jcondition-有条件的跳转" class="headerlink" title="jcondition 有条件的跳转"></a><code>jcondition</code> 有条件的跳转</h3><p>这些指令是<strong>条件跳转指令</strong>, 它们基于一组条件代码的状态, <strong>这些条件代码的状态存放在称为机器状态字 ( machine status word ) 的特殊寄存器中</strong>. 机器状态字的内容包括关于最后执行的算术运算的信息. 例如, 这个字的一个位表示最后的结果是否为 0. 另一个位表示最后结果是否为负数. 基于这些条件代码, 可以执行许多条件跳转. 例如, 如果最后一次算术运算结果为 0, 则 <code>jz</code> 指令就是跳转到指定参数标签. 否则, 程序就按照流程进入下一条指令.</p><p>许多条件分支的名称都是很直观的, 这些指令的运行, 都和一个特殊的比较指令有关, <code>cmp</code>( 见下文 ). 例如, 像 <code>jle</code> 和 <code>jne</code> 这种指令, 它们首先对参数进行 <code>cmp</code> 操作.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">je &lt;label ;&#x2F;&#x2F;当相等的时候跳转</span><br><span class="line">jne &lt;label ;&#x2F;&#x2F;当不相等的时候跳转</span><br><span class="line">jz &lt;label ;&#x2F;&#x2F;当最后结果为 0 的时候跳转</span><br><span class="line">jg &lt;label ;&#x2F;&#x2F;当大于的时候跳转</span><br><span class="line">jge &lt;label ;&#x2F;&#x2F;当大于等于的时候跳转</span><br><span class="line">jl &lt;label ;&#x2F;&#x2F;当小于的时候跳转</span><br><span class="line">jle &lt;label ;&#x2F;&#x2F;当小于等于的时候跳转</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp %ebx, %eax</span><br><span class="line">jle done ;&#x2F;&#x2F;如果 EAX 的值小于等于 EBX 的值, 就跳转到 &quot; done &quot; 标签, 否则就继续执行下一条指令.</span><br></pre></td></tr></table></figure><h3 id="cmp-比较指令"><a href="#cmp-比较指令" class="headerlink" title="cmp 比较指令"></a><code>cmp</code> 比较指令</h3><p>比较两个参数的值, <strong>适当地设置机器状态字中的条件代码</strong>. 此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp &lt;reg, &lt;reg</span><br><span class="line">cmp &lt;mem, &lt;reg</span><br><span class="line">cmp &lt;reg, &lt;mem</span><br><span class="line">cmp &lt;con, &lt;reg</span><br></pre></td></tr></table></figure><ul><li><em>例子</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmpb $10, (%ebx)</span><br><span class="line">jeq loop ;&#x2F;&#x2F;如果 EBX 的值等于整数常量 10, 则跳转到标签 &quot; loop &quot; 的位置.</span><br></pre></td></tr></table></figure><h3 id="call-ret-子程序调用与返回"><a href="#call-ret-子程序调用与返回" class="headerlink" title="call, ret 子程序调用与返回"></a><code>call, ret</code> 子程序调用与返回</h3><p>这两个指令<strong>实现子程序的调用和返回</strong>. <code>call</code> 指令首先将当前代码位置推到内存中硬件支持的栈内存上 ( 请看 <code>push</code> 指令 ), 然后<strong>无条件跳转到标签参数指定的代码位置</strong>. 与简单的 <code>jmp</code> 指令不同, <code>call</code> 指令保存了子程序完成时返回的位置. 就是 <strong><code>call</code> 指令结束后, 返回到调用之前的地址.</strong></p><p><code>ret</code> 指令<strong>实现子程序的返回.</strong> 该指令首先从栈中取出代码 ( 类似于 <code>pop</code> 指令 ). 然后它<strong>无条件跳转到检索到的代码位置</strong>.</p><ul><li><em>语法</em></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call &lt;label</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h1 id="调用约定-Calling-Convention"><a href="#调用约定-Calling-Convention" class="headerlink" title="调用约定 Calling Convention"></a>调用约定 Calling Convention</h1><hr><p>为了方便不同的程序员去分享代码和运行库, 并简化一般子程序的使用, 程序员们通常会遵守一定的约定 ( Calling Convention ). 调用约定是关于如何从例程调用和返回的协议. 例如，给定一组调用约定规则，程序员不需要检查子例程的定义来确定如何将参数传递给该子例程. 此外，给定一组调用约定规则，可以使高级语言编译器遵循规则，从而允许手动编码的汇编语言例程和高级语言例程相互调用.</p><p>我们将讲解被广泛使用的 C 语言调用约定. 遵循此约定将允许您编写可从 C ( 和C ++ ) 代码安全地调用的汇编语言子例程, 并且还允许您从汇编语言代码调用 C 函数库.</p><p>C 调用约定很大程度上取决于使用硬件支持的栈内存. 它基于 <code>push</code>, <code>pop</code>, <code>call</code> 和 <code>ret</code> 指令. 子程序的参数在栈上传递. 寄存器保存在栈中, 子程序使用的局部变量放在栈中. 在大多数处理器上实现的高级过程语言都使用了类似的调用约定.</p><p>调用约定分为两组. 第一组规则是面向子例程的调用者 ( Caller ) 的, 第二组规则面向子例程的编写者, 即被调用者 ( Callee ). 应该强调的是, 错误地遵守这些规则会导致程序的致命错误, 因为栈将处于不一致的状态; 因此, 在你自己的子例程中实现调用约定的时候, 务必当心.</p><p><img src="/images/Re_x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80_stack-convention.png" alt="convention"></p><p>将调用约定可视化的一种好方法是, 在子例程执行期间画一个栈内存附近的图. 上图 描绘了在执行具有三个参数和三个局部变量的子程序期间栈的内容. 栈中描绘的单元都是 32 位内存单元, 因此这些单元的内存地址相隔 4 个字节. 第一个参数位于距基指针 8 个字节的偏移处. 在栈参数的上方 ( 和基指针下方 ), <code>call</code> 指令在这放了返回地址, 从而导致从基指针到第一个参数有额外 4 个字节的偏移量. 当 <code>ret</code> 指令用于从子程序返回时, 它将跳转到栈中的返回地址.</p><h2 id="调用者约定-Caller-Rules"><a href="#调用者约定-Caller-Rules" class="headerlink" title="调用者约定 Caller Rules"></a>调用者约定 Caller Rules</h2><p>要进行子程序调用，调用者应该：</p><ol><li>在调用子例程之前, 调用者应该保存指定调用者保存 ( Caller-saved )的某些寄存器的内容. 调用者保存的寄存器是 EAX, ECX, EDX. 由于被调用的子程序可以修改这些寄存器, 所以如果调用者在子例程返回后依赖这些寄存器的值, 调用者必须将这些寄存器的值入栈, 然后就可以在子例程返回后恢复它们.</li><li>要把参数传递给子例程, 你可以在调用之前把参数入栈. 参数的入栈顺序应该是反着的, 就是最后一个参数应该最先入栈. 随着栈内存地址增大, 第一个参数将存储在最低的地址, 在历史上, 这种参数的反转用于允许函数传递可变数量的参数.</li><li>要调用子例程, 请使用<code>call</code>指令. 该指令将返回地址存到栈上, 并跳转到子程序的代码. 这个会调用子程序, 这个子程序应该遵循下面的被调用者约定.</li></ol><p>子程序返回后 ( 紧跟调用指令后 ), 调用者可以期望在寄存器 EAX 中找到子例程的返回值. 要恢复机器状态 ( machine state ), 调用者应该 :</p><ol><li>从栈中删除参数, 这会把栈恢复到调用之前的状态.</li><li>把 EAX, ECX, EDX 之前入栈的内容给出栈, 调用者可以假设子例程没有修改其它寄存器.</li><li><strong>例子</strong></li></ol><p>下面的代码就是个活生生的例子, 它展示了遵循约定的函数调用. 调用者正在调用一个带有 3 个整数参数的函数 myFunc. 第一个参数是 EAX, 第二个参数是常数 216; 第三个参数位于 EBX 的值所代表的内存地址.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push (%ebx) ;&#x2F;&#x2F;最后一个参数最先入栈</span><br><span class="line">push $216 ;&#x2F;&#x2F;把第二个参数入栈</span><br><span class="line">push %eax ;&#x2F;&#x2F;第一个参数最后入栈</span><br><span class="line"></span><br><span class="line">call myFunc ;&#x2F;&#x2F;调用这个函数 ( 假设以 C 语言的模式命名 )</span><br><span class="line"></span><br><span class="line">add $12, %esp</span><br></pre></td></tr></table></figure><p>注意, 在调用返回后, 调用者使用 <code>add</code> 指令来清理栈内存. 我们栈内存中有 12 个字节 ( 3 个参数, 每个参数 4 个字节 ), 然后栈内存地址增大. 因此, 为了摆脱掉这些参数, 我们可以直接往栈里面加个 12.</p><p>myFunc 生成的结果现在可以有用于寄存器 EAX. 调用者保存 ( Caller-saved ) 的寄存器 ( ECX, EDX ) 的值可能已经被修改. 如果调用者在调用之后使用它们，则需要在调用之前将它们保存在堆栈中并在调用之后恢复它们. 说白了就是把栈这个玩意当作临时存放点.</p><h2 id="被调用者约定-Callee-Rules"><a href="#被调用者约定-Callee-Rules" class="headerlink" title="被调用者约定 Callee Rules"></a>被调用者约定 Callee Rules</h2><p>子例程的定义应该遵循子例程开头的以下规则 :</p><ul><li>1.将 EBP 的值入栈, 然后用下面的指示信息把 ESP 的值复制到 EBP 中 :</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov  %esp, %ebp</span><br></pre></td></tr></table></figure><p>这个初始操作保留了基指针 EBP. 按照约定, 基指针作为栈上找到参数和变量的参考点. 当子程序正在执行的时候, 基指针保存了从子程序开始执行是的栈指针值的副本. 参数和局部变量将始终位于远离基指针值的已知常量偏移处. 我们在子例程的开头推送旧的基指针值，以便稍后在子例程返回时为调用者恢复适当的基指针值. 记住, 调用者不希望子例程修改基指针的值. 然后我们把栈指针移动到 EBP 中, 以获取访问参数和局部变量的参考点.</p><ul><li>2.接下来, 通过在栈中创建空间来分配局部变量. 回想一下, 栈会向下增长, 因此要在栈顶部创建空间, 栈指针应该递减. 栈指针递减的数量取决于所需局部变量的数量和大小. 例如, 如果需要 3 个局部整数 ( 每个 4 字节 ), 则需要将堆栈指针递减 12, 从而为这些局部变量腾出空间 ( 即sub $12, %esp ). 和参数一样, 局部变量将位于基指针的已知偏移处.</li><li>3.接下来, 保存将由函数使用的 被调用者保存的 ( Callee-saved ) 寄存器的值. 要存储寄存器, 请把它们入栈. 被调用者保存 ( Callee-saved ) 的寄存器是 EBX, EDI 和 ESI ( ESP 和 EBP 也将由调用约定保留, 但在这个步骤中不需要入栈 ).</li></ul><p>在完成这 3 步之后, 子例程的主体可以继续. 返回子例程的时候, 必须遵循以下步骤 :</p><ol><li>将返回值保存在 EAX 中.</li><li>恢复已经被修改的任何被调用者保存 ( Callee-saved ) 的寄存器 ( EDI 和 ESI ) 的旧值. 通过出栈来恢复它们. 当然应该按照相反的顺序把它们出栈.</li><li>释放局部变量. 显而易见的法子是把相应的值添加到栈指针 ( 因为空间是通过栈指针减去所需的数量来分配的 ). 事实上呢, 解除变量释放的错误的方法是将基指针中的值移动到栈指针 : <code>mov %ebp, %esp</code>. 这个法子有效, 是因为基指针始终包含栈指针在分配局部变量之前包含的值.</li><li>在返回之前, 立即通过把 EBP 出栈来恢复调用者的基指针值. 回想一下, 我们在进入子程序的时候做的第一件事是推动基指针保存它的旧值.</li><li>最后, 通过执行 <code>ret</code> 指令返回. 这个指令将从栈中找到并删除相应的返回地址 ( call 指令保存的那个 ).</li></ol><p>请注意, 被调用者的约定完全被分成了两半, 简直是彼此的镜像. 约定的前半部分适用于函数开头, 并且通常被称为定义函数的<em>序言</em> ( <em>prologue</em> ) .这个约定的后半部分适用于函数结尾, 因此通常被称为定义函数的<em>结尾</em> ( epilogue ).</p><ul><li><strong>例子</strong></li></ul><p>这是一个遵循被调用者约定的例子 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;启动代码部分</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">;将 myFunc 定义为全局 ( 导出 ) 函数</span><br><span class="line">.globl myFunc</span><br><span class="line">.type myFunc, @function</span><br><span class="line">myFunc :</span><br><span class="line">;子程序序言</span><br><span class="line">push %ebp ;&#x2F;&#x2F;保存基指针旧值</span><br><span class="line">mov %esp, %ebp ;&#x2F;&#x2F;设置基指针新值</span><br><span class="line">sub $4, %esp ;&#x2F;&#x2F;为一个 4 字节的变量腾出位置</span><br><span class="line">push %edi</span><br><span class="line">push %esi ;&#x2F;&#x2F;这个函数会修改 EDI 和 ESI, 所以先给它们入栈</span><br><span class="line">;不需要保存 EBX, EBP 和 ESP</span><br><span class="line"></span><br><span class="line">;子程序主体</span><br><span class="line">mov 8(%ebp), %eax ;&#x2F;&#x2F;把参数 1 的值移到 EAX 中</span><br><span class="line">mov 12(%ebp), %esi ;&#x2F;&#x2F;把参数 2 的值移到 ESI 中</span><br><span class="line">mov 16(%ebp), %edi ;&#x2F;&#x2F;把参数 3 的值移到 EDI 中</span><br><span class="line"></span><br><span class="line">mov %edi, -4(%ebp) ;&#x2F;&#x2F;把 EDI 移给局部变量</span><br><span class="line">add %esi, -4(%ebp) ;&#x2F;&#x2F;把 ESI 添加给局部变量</span><br><span class="line">add -4(%ebp), %eax ;&#x2F;&#x2F;将局部变量的内容添加到 EAX ( 最终结果 ) 中</span><br><span class="line"></span><br><span class="line">;子程序结尾</span><br><span class="line">pop %esi ;&#x2F;&#x2F;恢复寄存器的值</span><br><span class="line">pop %edi</span><br><span class="line">mov %ebp, %esp ;&#x2F;&#x2F;释放局部变量</span><br><span class="line">pop %ebp ;&#x2F;&#x2F;恢复调用者的基指针值</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>子程序序言执行标准操作, 即在 EBP ( 基指针 ) 中保存栈指针的副本, 通过递减栈指针来分配局部变量, 并在栈上保存寄存器的值.</p><p>在子例程的主体中, 我们可以看到基指针的使用. 在子程序执行期间, 参数和局部变量都位于与基指针的常量偏移处. 特别地, 我们注意到, 由于参数在调用子程序之前被放在栈中, 因此它们总是位于栈基指针 ( 即更高的地址 ) 之下. 子程序的第一个参数总是可以在内存地址 ( EBP+8 ) 找到, 第二个参数在 ( EBP+12 ), 第三个参数在 ( EBP+16). 类似地, 由于在设置基指针后分配局部变量, 因此它们总是位于栈上基指针 ( 即较低地址 ) 之上. 特别是, 第一个局部变量总是位于 ( EBP-4 ), 第二个位于 ( EBP-8 ), 以此类推. 这种基指针的常规使用, 让我们可以快速识别函数内部局部变量和参数的使用.</p><p>函数结尾基本上是函数序言的镜像. 从栈中恢复调用者的寄存器值, 通过重置栈指针来释放局部变量, 恢复调用者的基指针值, 并用 <code>ret</code> 指令返回调用者中的相应代码位置, 从哪来回哪去.</p><p><a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">维基百科 X86 调用约定</a></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
          <category> 汇编 </category>
          
          <category> x86 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> 汇编 </tag>
            
            <tag> x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re_C/C++语言基础</title>
      <link href="2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/16/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><hr><hr><h2 id="从源代码到可执行文件"><a href="#从源代码到可执行文件" class="headerlink" title="从源代码到可执行文件"></a>从源代码到可执行文件</h2><hr><p><strong>Linux下GCC的编译过程</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$gcc hello.c</span><br><span class="line">$./a.out</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>以上过程可分为4个步骤：预编译（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）.</p><p><img src="/images/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_compile.png" alt="compile"></p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p><code>$gcc -E hello.c -o hello.i</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__restrict __format, ...)</span></span>;</span><br><span class="line">......</span><br><span class="line">main() &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预编译过程主要处理源代码中以 “#” 开始的预编译指令：</p><ol><li><p>将所有的 “#define” 删除，并且展开所有的宏定义.</p></li><li><p>处理所有条件预编译指令，如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”.</p></li><li><p>处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置.注意，该过程递归执行.</p></li><li><p>删除所有注释.</p></li><li><p>添加行号和文件名标号.</p></li><li><p>保留所有的 #pragma 编译器指令.</p></li></ol><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>$gcc -S hello.c -o hello.s</code></p><figure class="highlight plain"><figcaption><span>"hello.c"</span></figcaption><table><tr><td class="code"><pre><span class="line">.file&quot;hello.c&quot;</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;hello,world!&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">movl$.LC0, %edi</span><br><span class="line">callputs</span><br><span class="line">movl$0, %eax</span><br><span class="line">popq%rbp</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件.</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p><code>$gcc -c hello.s -o hello.o</code></p><p>或者</p><p><code>$gcc -c hello.c -o hello.o</code></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ objdump -sd hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 bf000000 00e80000 0000b800  UH..............</span><br><span class="line"> 0010 0000005d c3                          ...].           </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 68656c6c 6f2c776f 726c6421 00        hello,world!.   </span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202855 62756e74 7520352e  .GCC: (Ubuntu 5.</span><br><span class="line"> 0010 342e302d 36756275 6e747531 7e31362e  4.0-6ubuntu1~16.</span><br><span class="line"> 0020 30342e31 32292035 2e342e30 20323031  04.12) 5.4.0 201</span><br><span class="line"> 0030 36303630 3900                        60609.          </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 15000000 00410e10 8602430d  .........A....C.</span><br><span class="line"> 0030 06500c07 08000000                    .P......        </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:55                   push   %rbp</span><br><span class="line">   1:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   4:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">   9:e8 00 00 00 00       callq  e &lt;main+0xe&gt;</span><br><span class="line">   e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  13:5d                   pop    %rbp</span><br><span class="line">  14:c3                   retq  </span><br></pre></td></tr></table></figure><p>汇编器将汇编代码转变成机器可以执行的指令.</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>$gcc hello.o -o hello</code></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ objdump -d -j .text hello</span><br><span class="line">......</span><br><span class="line">0000000000400526 &lt;main&gt;:</span><br><span class="line">  400526:55                   push   %rbp</span><br><span class="line">  400527:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  40052a:bf c4 05 40 00       mov    $0x4005c4,%edi</span><br><span class="line">  40052f:e8 cc fe ff ff       callq  400400 &lt;puts@plt&gt;</span><br><span class="line">  400534:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400539:5d                   pop    %rbp</span><br><span class="line">  40053a:c3                   retq   </span><br><span class="line">  40053b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>目标文件需要链接一大堆文件才能得到最终的可执行文件(上面只展示了链接后的main函数，可以和hello.o中的main函数作对比).链接过程主要包括地址和空间分配(Addre and Storage Allocation)、符号决议(Symbol Resolution) 和 重定向(Relocation)等.</p><p><img src="/images/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_test_c.jpg" alt="test_c"></p><h2 id="gcc技巧"><a href="#gcc技巧" class="headerlink" title="gcc技巧"></a>gcc技巧</h2><p>通常在编译后只会生成一个可执行文件，而中间过程生成的 <code>.i</code>、<code>.s</code>、<code>.o</code> 文件都不会被保存.我们可以使用参数 <code>-save-temps</code> 永久保存这些临时的中间文件.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc -save-temps hello.c</span><br><span class="line">$ ls</span><br><span class="line">a.out hello.c  hello.i  hello.o  hello.s</span><br></pre></td></tr></table></figure><p>这里要注意的是，gcc 默认使用动态链接，所以这里生成的 a.out 实际上是共享目标文件.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ file a.out</span><br><span class="line">a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=af83225f7c37ca2abfe89e140565dcaeab3aa6b7, not stripped</span><br></pre></td></tr></table></figure><p>使用参数 <code>--verbose</code> 可以输出 gcc 详细的工作流程.</p><p><code>$gcc hello.c -static --verbose</code></p><p>东西很多，我们主要关注下面几条信息：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc/x86_64-linux-gnu/5/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccQlc1QT.s</span><br><span class="line"></span><br><span class="line">as -v --64 -o /tmp/cchQkwiZ.o /tmp/ccQlc1QT.s</span><br><span class="line"></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/cckKaAL4.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --sysroot=/ --build-id -m elf_x86_64 --hash-style=gnu --as-needed -static -z relro /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbeginT.o -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. /tmp/cchQkwiZ.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure><p>三条指令分别是 <code>cc1</code>、<code>as</code> 和 <code>collect2</code>，cc1 是 gcc 的编译器，将 <code>.c</code> 文件编译为 <code>.s</code> 文件，as 是汇编器命令，将 <code>.s</code> 文件汇编成 <code>.o</code> 文件，collect2 是链接器命令，它是对命令 ld 的封装.静态链接时，gcc 将 C 语言运行时库的 5 个重要目标文件 <code>crt1.o</code>、<code>crti.o</code>、<code>crtbeginT.o</code>、<code>crtend.o</code>、<code>crtn.o</code> 和 <code>-lgcc</code>、<code>-lgcc_eh</code>、<code>-lc</code> 表示的 3 个静态库链接到可执行文件中.</p><h2 id="C-语言标准库"><a href="#C-语言标准库" class="headerlink" title="C 语言标准库"></a>C 语言标准库</h2><p>C 运行库（CRT）是一套庞大的代码库，以支撑程序能够正常地运行.其中 C 语言标准库占据了最主要地位.</p><p>常用的标准库文件头：</p><ul><li>标准输入输出（stdio.h）</li><li>字符操作（ctype.h）</li><li>字符串操作（string.h）</li><li>数学函数（math.h）</li><li>实用程序库（stdlib.h）</li><li>时间／日期（time.h）</li><li>断言（assert.h）</li><li>各种类型上的常数（limits.h &amp; float.h）</li><li>变长参数（stdarg.h）</li><li>非局部跳转（setjmp.h）</li></ul><p>glibc 即 GNU C Library，是为 GNU 操作系统开发的一个 C 标准库.glibc 主要由两部分组成，一部分是头文件，位于 <code>/usr/include</code>；另一部分是库的二进制文件.二进制文件部分主要是 C 语言标准库，有动态和静态两个版本，动态版本位于 <code>/lib/libc.so.6</code>，静态版本位于 <code>/usr/lib/libc.a</code>.</p><p>在漏洞利用的过程中，通常我们通过计算目标函数地址相对于已知函数地址在同一个 libc 中的偏移，来获得目标函数的虚拟地址，这时我们需要让本地的 libc 版本和远程的 libc 版本相同，可以先泄露几个函数的地址，然后在 <a href="http://libcdb.com/">libcdb.com</a> 中进行搜索来得到.</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>默认情况下，C 语言中的数字是有符号数，下面我们声明一个有符号整数和无符号整数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> var2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>有符号整数<ul><li>可以表示为正数或负数</li><li><code>int</code> 的范围：<code>-2,147,483,648 ~ 2,147,483,647</code></li></ul></li><li>无符号整数<ul><li>只能表示为零或正数</li><li><code>unsigned int</code> 的范围：<code>0 ~ 4,294,967,295</code></li></ul></li></ul><p><code>signed</code> 或者 <code>unsigned</code> 取决于整数类型是否可以携带标志 <code>+/-</code>：</p><ul><li>Signed<ul><li>int</li><li>signed int</li><li>long</li></ul></li><li>Unsigned<ul><li>unit</li><li>unsigned int</li><li>unsigned long</li></ul></li></ul><p>在 <code>signed int</code> 中，二进制最高位被称作符号位，符号位被设置为 <code>1</code> 时，表示值为负，当设置为 <code>0</code> 时，值为非负：</p><ul><li>0x7FFFFFFF = 2147493647<ul><li>01111111111111111111111111111111</li></ul></li><li>0x80000000 = -2147483647<ul><li>10000000000000000000000000000000</li></ul></li><li>0xFFFFFFFF = -1<ul><li>11111111111111111111111111111111</li></ul></li></ul><p>二进制<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin#3">补码</a>以一种适合于二进制加法器的方式来表示负数，当一个二进制补码形式表示的负数和与它的绝对值相等的正数相加时，结果为 0.首先以二进制方式写出正数，然后对所有位取反，最后加 1 就可以得到该数的二进制补码：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">eg: 0x00123456</span><br><span class="line">  = 1193046</span><br><span class="line">  = 00000000000100100011010001010110</span><br><span class="line"> ~= 11111111111011011100101110101001</span><br><span class="line"> += 11111111111011011100101110101010</span><br><span class="line">  = -1193046 (0xFFEDCBAA)</span><br></pre></td></tr></table></figure><p>编译器需要根据变量类型信息编译成相应的指令：</p><ul><li>有符号指令<ul><li>IDIV：带符号除法指令</li><li>IMUL：带符号乘法指令</li><li>SAL：算术左移指令（保留符号）</li><li>SAR：右移右移指令（保留符号）</li><li>MOVSX：带符号扩展传送指令</li><li>JL：当小于时跳转指令</li><li>JLE：当小于或等于时跳转指令</li><li>JG：当大于时跳转指令</li><li>JGE：当大于或等于时跳转指令</li></ul></li><li>无符号指令<ul><li>DIV：除法指令</li><li>MUL：乘法指令</li><li>SHL：逻辑左移指令</li><li>SHR：逻辑右移指令</li><li>MOVZX：无符号扩展传送指令</li><li>JB：当小于时跳转指令</li><li>JBE：当小于或等于时跳转指令</li><li>JA：当大于时跳转指令</li><li>JAE：当大于或等于时跳转指令</li></ul></li></ul><p>32 位机器上的整型数据类型，不同的系统可能会有不同：</p><table><thead><tr><th>C 数据类型</th><th>最小值</th><th>最大值</th><th>最小大小</th></tr></thead><tbody><tr><td>char</td><td>-128</td><td>127</td><td>8 bits</td></tr><tr><td>short</td><td>-32 768</td><td>32 767</td><td>16 bits</td></tr><tr><td>int</td><td>-2 147 483 648</td><td>2 147 483 647</td><td>16 bits</td></tr><tr><td>long</td><td>-2 147 483 648</td><td>2 147 483 647</td><td>32 bits</td></tr><tr><td>long long</td><td>-9 223 372 036 854 775 808</td><td>9 223 372 036 854 775 807</td><td>64 bits</td></tr></tbody></table><p>固定大小的数据类型：</p><ul><li><p><code>int [# of bits]_t</code></p><ul><li>int8_t, int16_t, int32_t</li></ul></li><li><p><code>uint[# of bits]_t</code></p><ul><li>uint8_t, uint16_t, uint32_t</li></ul></li><li><p>有符号整数</p><ul><li><img src="/images/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_signed_integer.png" alt="signed_integer"></li></ul></li><li><p>无符号整数</p><ul><li><img src="/images/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_unsigned_integer.png" alt="unsigned_integer"></li></ul></li></ul><p>更多信息在 <code>stdint.h</code> 和 <code>limits.h</code> 中：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">man stdint.h</span><br><span class="line">cat /usr/include/stdint.h</span><br><span class="line">man limits.h</span><br><span class="line">cat /usr/include/limits.h</span><br></pre></td></tr></table></figure><h2 id="格式化输出函数"><a href="#格式化输出函数" class="headerlink" title="格式化输出函数"></a>格式化输出函数</h2><p>C 标准中定义了下面的格式化输出函数（参考 <code>man ３ printf</code>）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vdprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>fprintf()</code> 按照格式字符串的内容将输出写入流中.三个参数为流、格式字符串和变参列表.</li><li><code>printf()</code> 等同于 <code>fprintf()</code>，但是它假定输出流为 <code>stdout</code>.</li><li><code>sprintf()</code> 等同于 <code>fprintf()</code>，但是输出不是写入流而是写入数组.在写入的字符串末尾必须添加一个空字符.</li><li><code>snprintf()</code> 等同于 <code>sprintf()</code>，但是它指定了可写入字符的最大值 <code>size</code>.当 <code>size</code> 大于零时，输出字符超过第 <code>size-1</code> 的部分会被舍弃而不会写入数组中，在写入数组的字符串末尾会添加一个空字符.</li><li><code>dprintf()</code> 等同于 <code>fprintf()</code>，但是它输出不是流而是一个文件描述符 <code>fd</code>.</li><li><code>vfprintf()</code>、<code>vprintf()</code>、<code>vsprintf()</code>、<code>vsnprintf()</code>、<code>vdprintf()</code> 分别与上面的函数对应，只是它们将变参列表换成了 <code>va_list</code> 类型的参数.</li></ul><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><p>格式字符串是由普通字符（ordinary character）（包括 <code>%</code>）和转换规则（conversion specification）构成的字符序列.普通字符被原封不动地复制到输出流中.转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中.</p><p>一个转换规则有可选部分和必需部分组成：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符</span><br></pre></td></tr></table></figure><ul><li>（必需）转换指示符</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>d</code>, <code>i</code></td><td>有符号十进制数值 <code>int</code>。’<code>%d</code>‘ 与 ‘<code>%i</code>‘ 对于输出是同义；但对于 <code>scanf()</code> 输入二者不同，其中 <code>%i</code> 在输入值有前缀 <code>0x</code> 或 <code>0</code> 时，分别表示 16 进制或 8 进制的值。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空</td></tr><tr><td><code>u</code></td><td>十进制 <code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空</td></tr><tr><td><code>f</code>, <code>F</code></td><td><code>double</code> 型输出 10 进制定点表示。’<code>f</code>‘ 与 ‘<code>F</code>‘ 差异是表示无穷与 NaN 时，’<code>f</code>‘ 输出 ‘<code>inf</code>‘, ‘<code>infinity</code>‘ 与 ‘<code>nan</code>‘；’<code>F</code>‘ 输出 ‘<code>INF</code>‘, ‘<code>INFINITY</code>‘ 与 ‘<code>NAN</code>‘。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为 6。如果精度为 0 且没有 # 标记，则不出现小数点。小数点左侧至少一位数字</td></tr><tr><td><code>e</code>, <code>E</code></td><td><code>double</code> 值，输出形式为 10 进制的([<code>-</code>]d.ddd <code>e</code>[<code>+</code>/<code>-</code>]ddd). <code>E</code> 版本使用的指数符号为 <code>E</code>（而不是<code>e</code>）。指数部分至少包含 2 位数字，如果值为 0，则指数部分为 00。Windows 系统，指数部分至少为 3 位数字，例如 1.5e002，也可用 Microsoft 版的运行时函数 <code>_set_output_format</code> 修改。小数点前存在 1 位数字。小数点后的数字位数等于精度。精度默认为 6。如果精度为 0 且没有 # 标记，则不出现小数点</td></tr><tr><td><code>g</code>, <code>G</code></td><td><code>double</code> 型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。’<code>g</code>‘ 使用小写字母，’<code>G</code>‘ 使用大写字母。小数点右侧的尾数 0 不被显示；显示小数点仅当输出的小数部分不为 0</td></tr><tr><td><code>x</code>, <code>X</code></td><td>16 进制 <code>unsigned int</code>。’<code>x</code>‘ 使用小写字母；’<code>X</code>‘ 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空</td></tr><tr><td><code>o</code></td><td>8 进制 <code>unsigned int</code>。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空</td></tr><tr><td><code>s</code></td><td>如果没有用 <code>l</code> 标志，输出 <code>null</code> 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 <code>l</code> 标志，则对应函数参数指向 <code>wchar_t</code> 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 <code>wcrtomb</code> 函数</td></tr><tr><td><code>c</code></td><td>如果没有用 <code>l</code> 标志，把 <code>int</code> 参数转为 <code>unsigned char</code> 型输出；如果用了 <code>l</code> 标志，把 <code>wint_t</code> 参数转为包含两个元素的 <code>wchart_t</code> 数组，其中第一个元素包含要输出的字符，第二个元素为 <code>null</code> 宽字符</td></tr><tr><td><code>p</code></td><td><code>void *</code> 型，输出对应变量的值。<code>printf(&quot;%p&quot;, a)</code> 用地址的格式打印变量 <code>a</code> 的值，<code>printf(&quot;%p&quot;, &amp;a)</code> 打印变量 <code>a</code> 所在的地址</td></tr><tr><td><code>a</code>, <code>A</code></td><td><code>double</code> 型的 16 进制表示，”[−]0xh.hhhh p±d”。其中指数部分为 10 进制表示的形式。例如：1025.010 输出为 0x1.004000p+10。’<code>a</code>‘ 使用小写字母，’<code>A</code>‘ 使用大写字母</td></tr><tr><td><code>n</code></td><td>不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</td></tr><tr><td><code>%</code></td><td>‘<code>%</code>‘ 字面值，不接受任何除了 <code>参数</code> 以外的部分</td></tr></tbody></table><ul><li>（可选）参数</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>n$</code></td><td><code>n</code> 是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了 <code>参数</code>，则其他所有占位符必须也使用 <code>参数</code>。例：<code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)</code> 产生 “<code>17 0x11; 16 0x10</code>“</td></tr></tbody></table><ul><li>（可选）标志</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td>总是表示有符号数值的 ‘<code>+</code>‘ 或 ‘<code>-</code>‘ 号，缺省情况是忽略正数的符号。仅适用于数值类型</td></tr><tr><td><em>空格</em></td><td>使得有符号数的输出如果没有正负号或者输出 0 个字符，则前缀 1 个空格。如果空格与 ‘<code>+</code>‘ 同时出现，则空格说明符被忽略</td></tr><tr><td><code>-</code></td><td>左对齐。缺省情况是右对齐</td></tr><tr><td><code>#</code></td><td>对于 ‘<code>g</code>‘ 与 ‘<code>G</code>‘，不删除尾部 0 以表示精度。对于 ‘<code>f</code>‘, ‘<code>F</code>‘, ‘<code>e</code>‘, ‘<code>E</code>‘, ‘<code>g</code>‘, ‘<code>G</code>‘, 总是输出小数点。对于 ‘<code>o</code>‘, ‘<code>x</code>‘, ‘<code>X</code>‘, 在非 0 数值前分别输出前缀 <code>0</code>, <code>0x</code> 和 <code>0X</code>表示数制</td></tr><tr><td><code>0</code></td><td>如果 <code>宽度</code> 选项前缀为 <code>0</code>，则在左侧用 <code>0</code> 填充直至达到宽度要求。例如 <code>printf(&quot;%2d&quot;, 3)</code> 输出 “<code>3</code>“，而 <code>printf(&quot;%02d&quot;, 3)</code> 输出 “<code>03</code>“。如果 <code>0</code> 与 <code>-</code> 均出现，则 <code>0</code> 被忽略，即左对齐依然用空格填充</td></tr></tbody></table><ul><li>（可选）宽度</li></ul><p>是一个用来指定输出字符的最小个数的十进制非负整数.如果实际位数多于定义的宽度,则按实际位数输出；如果实际位数少于定义的宽度则补以空格或 0.</p><ul><li>（可选）精度</li></ul><p>精度是用来指示打印字符个数、小数位数或者有效数字个数的非负十进制整数.对于 <code>d</code>、<code>i</code>、<code>u</code>、<code>x</code>、<code>o</code> 的整型数值，是指最小数字位数，不足的位要在左侧补 0，如果超过也不截断，缺省值为 1.对于 <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code> 的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入；缺省值为 6.对于 <code>g</code>, <code>G</code> 的浮点数值，是指有效数字的最大位数.对于 <code>s</code> 的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断.如果域宽为 <code>*</code>，则由对应的函数参数的值为当前域宽.如果仅给出了小数点，则域宽为 0.</p><ul><li>（可选）长度</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>hh</code></td><td>对于整数类型，<code>printf</code> 期待一个从 <code>char</code> 提升的 <code>int</code> 整型参数</td></tr><tr><td><code>h</code></td><td>对于整数类型，<code>printf</code> 期待一个从 <code>short</code> 提升的 <code>int</code> 整型参数</td></tr><tr><td><code>l</code></td><td>对于整数类型，<code>printf</code> 期待一个 <code>long</code> 整型参数。对于浮点类型，<code>printf</code> 期待一个 <code>double</code> 整型参数。对于字符串 <code>s</code> 类型，<code>printf</code> 期待一个 <code>wchar_t</code> 指针参数。对于字符 <code>c</code> 类型，<code>printf</code> 期待一个 <code>wint_t</code> 型的参数</td></tr><tr><td><code>ll</code></td><td>对于整数类型，<code>printf</code> 期待一个 <code>long long</code> 整型参数。Microsoft 也可以使用 <code>I64</code></td></tr><tr><td><code>L</code></td><td>对于浮点类型，<code>printf</code> 期待一个 <code>long double</code> 整型参数</td></tr><tr><td><code>z</code></td><td>对于整数类型，<code>printf</code> 期待一个 <code>size_t</code> 整型参数</td></tr><tr><td><code>j</code></td><td>对于整数类型，<code>printf</code> 期待一个 <code>intmax_t</code> 整型参数</td></tr><tr><td><code>t</code></td><td>对于整数类型，<code>printf</code> 期待一个 <code>ptrdiff_t</code> 整型参数</td></tr></tbody></table><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %%&quot;</span>);           <span class="comment">// &quot;Hello %&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);       <span class="comment">// &quot;Hello World!&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: %d&quot;</span>, <span class="number">123</span>);    <span class="comment">// &quot;Number: 123&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s&quot;</span>, <span class="string">&quot;Format&quot;</span>, <span class="string">&quot;Strings&quot;</span>);   <span class="comment">// &quot;Format Strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%12c&quot;</span>, <span class="string">&#x27;A&#x27;</span>);          <span class="comment">// &quot;           A&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%16s&quot;</span>, <span class="string">&quot;Hello&quot;</span>);      <span class="comment">// &quot;          Hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%12c%n&quot;</span>, <span class="string">&#x27;A&#x27;</span>, &amp;n);    <span class="comment">// n = 12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%16s%n&quot;</span>, <span class="string">&quot;Hello!&quot;</span>, &amp;n); <span class="comment">// n = 16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$s %1$s&quot;</span>, <span class="string">&quot;Format&quot;</span>, <span class="string">&quot;Strings&quot;</span>); <span class="comment">// &quot;Strings Format&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%42c%1$n&quot;</span>, &amp;n);       <span class="comment">// 首先输出41个空格，然后输出 n 的低八位地址作为一个字符</span></span><br></pre></td></tr></table></figure><hr><h1 id="关于-C"><a href="#关于-C" class="headerlink" title="关于 C++"></a>关于 C++</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$gcc hello.c</span><br><span class="line">$a.exe</span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line"></span><br><span class="line">gcc -S hello.c -o hello.s</span><br><span class="line"></span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line">gcc hello.o -o hello</span><br><span class="line"></span><br><span class="line">gcc -save-temps hello.c</span><br><span class="line">ls</span><br><span class="line">a.exe  hello.c  hello.exe  hello.i  hello.o  hello.s</span><br><span class="line"></span><br><span class="line">gcc hello.c -static --verbose</span><br></pre></td></tr></table></figure><p><img src="/images/Re_c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_test_cpp.jpg" alt="test_cpp"></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大创_1</title>
      <link href="2021/03/14/%E5%A4%A7%E5%88%9B/"/>
      <url>2021/03/14/%E5%A4%A7%E5%88%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大创-1"><a href="#大创-1" class="headerlink" title="大创_1"></a>大创_1</h1><hr><hr><h2 id="ssp-19——两种新的攻击方式"><a href="#ssp-19——两种新的攻击方式" class="headerlink" title="ssp_19——两种新的攻击方式"></a>ssp_19——两种新的攻击方式</h2><hr><h3 id="Cache-Attacks当前面对的挑战"><a href="#Cache-Attacks当前面对的挑战" class="headerlink" title="Cache Attacks当前面对的挑战"></a>Cache Attacks当前面对的挑战</h3><p> 在目前的现代计算机系统中，LLC被物理划分为多个切片，缓存层次结构不再具有包容性，而转向非包容性缓存层次结构，且这种趋势将会继续增长.但是以前的LLC attacks是依赖于LLC的包容性，这种攻击方法不再能够有效地实现攻击目的，即便如此在非包容性缓存层次结构的计算机中，我们依然可以对目录进行攻击，通过对LLC attack中典型的Prime+Probe攻击和Flush+Reload攻击进行新的设计，达到在非包容性缓存层次结构中实现有效的侧信道攻击.</p><h3 id="现代Cross-Core-Cache-Attacks"><a href="#现代Cross-Core-Cache-Attacks" class="headerlink" title="现代Cross-Core Cache Attacks"></a>现代Cross-Core Cache Attacks</h3><p>目前已有Prime+Probe攻击和Flush+Reload攻击.</p><p> 其中Flush+Reload攻击依赖于共享内存进行Reload操作，并使用clflush刷新目标地址.基于这种情况我们可以设计Evict+Reload攻击，它依赖于共享内存而不使用clflush指令，只要构建出具有与目标地址同样数目地址的驱逐集（还没搞懂），就可以使用缓存冲突来驱逐目标地址.</p><p> 而Prime+Probe则无需共享内存，攻击步骤分为prime，wait和probe.在prime步骤中，攻击者通过访问驱逐集中的一组地址来从缓存中驱逐目标地址，然后wait，最后的probe步骤中，重新访问prime中使用的地址组来检测靶机的活动，若未命中则说明目标地址已访问.</p><hr><p><strong><em>可以看到，在两种新的攻击方式中，一个共同点是需要构造驱逐集，而驱逐集的构造却是很困难的，这也是研究的难点.</em></strong></p><h1 id="大创-2"><a href="#大创-2" class="headerlink" title="大创_2"></a>大创_2</h1><hr><hr><h2 id="ssp-19——攻击非包容性缓存面临的挑战"><a href="#ssp-19——攻击非包容性缓存面临的挑战" class="headerlink" title="ssp_19——攻击非包容性缓存面临的挑战"></a>ssp_19——攻击非包容性缓存面临的挑战</h2><hr><h3 id="驱逐集"><a href="#驱逐集" class="headerlink" title="驱逐集"></a>驱逐集</h3><p>​    驱逐集（EV）是地址的集合，它们全部映射到特定缓存切片的特定缓存集，并且能够驱逐该切片中整个集的当前内容.在具<em>W</em>-slice方式的切片中，驱逐集必须至少包含<em>W</em>-slice的地址，用来占据所有的方式并且驱逐出该组的全部内容.</p><p>我们将Eviction Addresses称为Eviction Set中的地址.在包含性LLC中，Evict + Reload和Prime + Probe都使用Eviction Sets从私有缓存中驱逐目标地址.此外，Prime Probe中的探测操作测量访问驱逐集的延迟，以推断被攻击者的活动.</p><h3 id="挑战：缺乏对被攻击者私人缓存的可见性"><a href="#挑战：缺乏对被攻击者私人缓存的可见性" class="headerlink" title="挑战：缺乏对被攻击者私人缓存的可见性"></a>挑战：缺乏对被攻击者私人缓存的可见性</h3><p>​    在非包容性缓存层次结构中，在核心上运行的攻击者似乎无法从另一个核心的私有缓存中驱逐一个地址，即它无法在第二个核心的缓存中创建包容性被攻击者（没理解这指的是什么）.从下图中可以了解原因，图中显示了一个共享LLC和两个私有缓存（Private Cache）.攻击者在缓存1和缓存0上的被攻击者上运行；目标行在缓存0中以浅色显示.</p><p><img src="/images/%E5%A4%A7%E5%88%9B_2.png" alt="(a)为包容性缓存，(b)为非包容性缓存"></p><p><em>上图表示了攻击者尝试从（a）和（b）这两种缓存层次结构中的被攻击者私有缓存中驱逐出目标行.</em></p><p>图中（a）显示了包容性层次结构，LLC集包含来自攻击者的行（阴影部分）与来自被攻击者的目标行（浅色部分），攻击者引用一个映射到同一LLC集中的附加行，该行会把LLC中的目标行驱逐.由于具有包容性且来自Private Cache 0，所以会创建一个包容性被攻击者.这种在其他缓存上创建包容性被攻击者的能力是支持跨核攻击的能力.（被攻击者是如何被创建的？意思是创建了一个新的组吗?）</p><p>图中（b）显示了非包容性层次结构，此时，目标行位于被攻击者的缓存中而非LLC中.因此，当攻击者引用映射到同一LLC集的附加行时，不会向Cache 0发送失效命令.那么攻击者就无法在被攻击者的缓存中创建包容性被攻击者.</p><hr><p><strong><em>问题1：包容性被攻击者是什么？是被攻击者缓存中一个新的具有包容性的组吗?</em></strong></p><p><strong><em>问题2：W-slice方式是什么方式？</em></strong></p><p><strong><em>思考：如何在Risc-v上实现这种操作？</em></strong></p><h1 id="大创-3"><a href="#大创-3" class="headerlink" title="大创_3"></a>大创_3</h1><hr><hr><h2 id="ssp-19——构建驱逐集的困难"><a href="#ssp-19——构建驱逐集的困难" class="headerlink" title="ssp_19——构建驱逐集的困难"></a>ssp_19——构建驱逐集的困难</h2><hr><h3 id="构建驱逐集的难点"><a href="#构建驱逐集的难点" class="headerlink" title="构建驱逐集的难点"></a>构建驱逐集的难点</h3><p><img src="/images/%E5%A4%A7%E5%88%9B_3.png" alt="(a)为包容性缓存，(b)为非包容性缓存"></p><p>图中显示了私有缓存和共享LLC的两个片段，被攻击者和攻击者在同一核心上运行.</p><p>（a）显示了包含层次结构.目标行位于私有缓存中和LLC的一个片中，要从缓存层次结构中逐出目标，攻击者只需要引用足够的行来填充LLC的相应片段中的相关集合.这是因为，当这些行填充集合时，它们也将填充私有缓存中的集合，并从中逐出目标行.这是EV，以暗色调显示，访问每行的顺序和次数在需要驱逐目标地址的EV中，由LLC切片中使用的替换算法确定.</p><p>（b）显示了非包容性层次结构.在这种情况下，目标行仅在私有缓存中，当核心访问与（a）相同的高速缓存行时，这些行首先绕过私有高速缓存、绕过LLC.私有缓存中使用的替换算法将确定目标线何时从私有缓存逐出到LLC中.当目标被驱逐时，它将转到LLC切片之一，具体取决于地址到切片的映射.然后，核心需要将足够的线驱逐到LLC切片中以创建足够的冲突以从切片中驱逐目标线.</p><p>总的来说，驱逐目标地址所需的EV中每条线的访问顺序和次数由多个因素决定，包括私有缓存中使用的替换算法，线路地址到LLC切片的映射，以及LLC切片中使用的替换算法.在包容性情况中，只有LLC中的替换算法会影响驱逐.</p><p>我们注意到，在非包容性缓存层次结构中，私有缓存和LLC切片中的替换算法可能非常复杂.选择什么特定行作为替换被攻击者不仅取决于对行的访问次数和顺序，还取决于高速缓存中行的一致性状态.具体来说，我们凭经验观察到LLC切片中的替换算法试图最小化多个私有缓存中存在的行的驱逐.这种特殊的启发式方法会影响为Evict + Reload攻击创建有效EV的能力，其中线路在攻击者和被攻击者之间共享.</p><h3 id="攻击的概述"><a href="#攻击的概述" class="headerlink" title="攻击的概述"></a>攻击的概述</h3><p>为了解决创建EV的难题，提出了一种为非包容性缓存创建EV的新方法.使用EV和其他技术，专家对Intel Skylake-X目录结构进行了逆向工程，此过程揭示了目录条目替换策略和包含性属性的关键见解.</p><p>特别是，得出了攻击者何时能够使用该目录在非包容性缓存层次结构的私有缓存中创建包含被攻击者的条件.基于逆向工程结果和新的EV构建方法，可以在非包含缓存层次结构中设计有效的“Prime + Probe”和“Evict + Reload”攻击.</p><hr><p><strong><em>下一目标：弄明白驱逐集如何构建，是否可以自行实现？</em></strong></p><h1 id="大创-4"><a href="#大创-4" class="headerlink" title="大创_4"></a>大创_4</h1><hr><hr><h2 id="ssp19——构建驱逐集"><a href="#ssp19——构建驱逐集" class="headerlink" title="ssp19——构建驱逐集"></a>ssp19——构建驱逐集</h2><hr><p>在前面提出了用于非包容性缓存的EV构造算法，EV是一个完全占用特定缓存集的LLC切片的内存地址集合，EV也就是驱逐集.有厉害的前辈已经提出了一种用于包容性缓存的EV构造算法，但是它并不适用于非包容性缓存，原因在前面也说过(见<a href="https://aloof77.github.io/2021/03/14/%E5%A4%A7%E5%88%9B_2/">大创_2</a>)，而通过将其中一个重要的子程序check_conflict开发一个新的实现，可以解决这个问题.</p><hr><h3 id="检查冲突在EV构造算法中的作用"><a href="#检查冲突在EV构造算法中的作用" class="headerlink" title="检查冲突在EV构造算法中的作用"></a>检查冲突在EV构造算法中的作用</h3><p>在EV构造算法中，使用了一个叫做check_conflict(地址 x，集合U)的函数，如算法2所示.该函数会检查集合U中地址是否与LCC中的x冲突，如果U包含<em>W</em>-slice或更多地址，则该函数应返回true，这些地址映射到同一切片并设置为x；否则该函数应返回false. EV构造算法仅在此函数具有非常低的误报率和漏报率时才有效.</p><p><img src="/images/%E5%A4%A7%E5%88%9B_4_%E7%AE%97%E6%B3%952.png" alt="算法2"></p><p>想要知道为什么这样的要求如此重要，就必须考虑如何在EV构造算法中使用check_conflict.高级的想法是从一个已知与LLC切片中的x冲突的集合U开始，然后从集合U中移除地址y并获得新的集合U<sup>t</sup>=U-y.如果在检查U<sup>t</sup>时x的冲突消失，那么我们知道y一定对冲突产生了影响，在这种情况下y被认为在EV的x中.显然，该操作需要较低的误报率和漏报率来准确地观察冲突的消失。附录A提供了有关如何使用算法的更多详细信息，以及高精度实现的重要性.</p><hr><h3 id="新检查冲突功能"><a href="#新检查冲突功能" class="headerlink" title="新检查冲突功能"></a>新检查冲突功能</h3><p>首先讨论为什么之前的check_conflict函数在对非包容性缓存应用是具有较高的漏报率，然后展示如何修改函数来达到在非包含性缓存中共组的目的.以下讨论中，假设U中所有地址具有与x相同的LLC索引位.</p><p><strong>Baseline</strong> <strong>check_conflict</strong> <strong>.</strong> (基函数) 在算法2中，基函数首先访问目标地址x，确保该行被高速缓存，然后访问U中所有的地址，如果稍后访问第x行只需要很短的时间，则意味着该行依然被缓存；否则，意味着该行已被逐出缓存.因此，访问等待时间可用于确定U是否包含足够多用于驱逐x的地址.</p><p>当应用于非包容性缓存时，此功能有较高的漏报率。具体来看，当U包含足够的地址时，如果它们都在LLC中，将会驱逐x，该函数应该返回true，但是也可能返回false.为了了解这种漏报是如何发生的，先考虑一个最小的U，它具有映射到与x相同的LLC切片正好是<em>W</em>-slice地址.在非包容性缓存中，当访问U时，这些<em>W</em>-slice中的一些地址行可能保留在L2中，并且永远不会被从L2驱逐到LLC中.因此，这些地址没有机会与LLC中的x冲突，并且x不会被驱逐，导致漏报.此外，由于L2的替换算法既不是LRU也不是伪LRU，简单地多次访问U并不能保证较小的漏报率.</p><p><strong>Naive New</strong> <strong>check_conflict</strong> **.**为了降低误报率，我们需要将U中的所有行从L2刷新到LLC中.如果有一个特殊的指令很方便可以做到这点那很好，但是x86架构中不存在这样的指令，因此，我们利用L2冲突来实现刷新效果。</p><p>创建一个额外的地址集合，称为L2占用集，其中包含映射到与U相同的L2集的W<sub>L2</sub>地址.访问时，L2占用设置强制使U中所有的行被驱逐到LLC.修改的check_conflict函数如算法3所示.我们在访问x和基函数中的所有地址(第2-5行)后，访问L2占用集中的地址(第6-8行).通过这种方式，U中的每一行都被驱逐到x所在的LLC切片，并且我们可以显著降低漏报率.</p><p><img src="/images/%E5%A4%A7%E5%88%9B_4_%E7%AE%97%E6%B3%953.png" alt="算法3"></p><p>然而，这种单纯的方法具有很高的误报率，当U中没有足够的地址使从LLC切片驱逐x时，可能会出现误报，但是L2占用集中的某些地址最终会被驱逐到LLC，在它们的帮助下，会从LLC中驱逐x，此时函数应当返回false，但是事实上会返回true.</p><p><strong>Reliable New</strong> <strong>check_conflict</strong> <strong>.</strong> 为了减少新函数中的误报率，我们需要确保对L2占用集的访问不会干扰LLC中U和x之间的冲突。我们可以通过利用L2和LLC之间的一对多映射关系来实现这一点.</p><p>为了设计的可靠性，我们选择L2占用集，使其地址映射到与U中的地址相同的LLC集.前面说到，像L2这样的高级缓存包含的缓存集比LLC等低级缓存更少.</p><p><code>例如，在Skylake-X中，L2具有1024组，而LLC切片具有2048组。</code></p><p>相应地，L2使用来自物理地址的10位(位6-15)最为索引，而LLC切片使用11位(位6-16)作为索引.因此，可以通过繁转U中W<sub>12</sub>地址的位16来构造L2占用集，这些地址可用于从L2中驱逐U，但不与LLC中的U冲突.</p><hr><p><strong><em>总结一下，重新设计了一个可靠的check_conflict函数，具有低误报率和漏报率，且可用于非包容性缓存的EV构造算法.</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 大创 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aloof</title>
      <link href="2021/02/16/Aloof/"/>
      <url>2021/02/16/Aloof/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Aloof"><a href="#Aloof" class="headerlink" title="Aloof"></a>Aloof</h1><hr><hr><h2 id="愿我如星君如月，夜夜流光相皎洁"><a href="#愿我如星君如月，夜夜流光相皎洁" class="headerlink" title="愿我如星君如月，夜夜流光相皎洁"></a><em><strong>愿我如星君如月，夜夜流光相皎洁</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> Aloof </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aloof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/02/16/hello-world/"/>
      <url>2021/02/16/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
